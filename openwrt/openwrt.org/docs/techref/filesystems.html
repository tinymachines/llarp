
<h1 class="sectionedit1" id="filesystems">Filesystems</h1>
<div class="level1">

<p>
This article is about file systems used by OpenWrt for device built-in flash.
</p>

<p>
For installing additional file systems, including partitioning and mounting, see this page for <a href="/docs/guide-user/storage/start" class="wikilink1" title="docs:guide-user:storage:start" data-wiki-id="docs:guide-user:storage:start">general storage</a> as well as this page to other common <a href="/docs/guide-user/storage/filesystems-and-partitions" class="wikilink1" title="docs:guide-user:storage:filesystems-and-partitions" data-wiki-id="docs:guide-user:storage:filesystems-and-partitions">filesystems</a>.
</p>

<p>
Please read about the <a href="/docs/techref/flash.layout" class="wikilink1" title="docs:techref:flash.layout" data-wiki-id="docs:techref:flash.layout">flash.layout</a> as well. Also, note that there are two types of flash memory: <a href="https://en.wikipedia.org/wiki/Flash_memory#NOR_flash" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Flash_memory#NOR_flash">NOR flash</a> and <a href="https://en.wikipedia.org/wiki/Flash_memory#NAND_flash" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Flash_memory#NAND_flash">NAND flash</a>. See also <a href="/docs/techref/mtd" class="wikilink1" title="docs:techref:mtd" data-wiki-id="docs:techref:mtd">mtd</a>. 
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Filesystems&quot;,&quot;hid&quot;:&quot;filesystems&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-579&quot;} -->
<h2 class="sectionedit2" id="common_file_system">Common File System</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Common File System&quot;,&quot;hid&quot;:&quot;common_file_system&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;580-611&quot;} -->
<h3 class="sectionedit3" id="overlayfs">OverlayFS</h3>
<div class="level3">

<p>
Used to merge two filesystems, one read-only and the other writable. <a href="/docs/techref/flash.layout" class="wikilink1" title="docs:techref:flash.layout" data-wiki-id="docs:techref:flash.layout">flash.layout</a> explains how this is used in OpenWrt.
</p>
<ul>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/OverlayFS" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/OverlayFS">OverlayFS</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html" class="urlextern" title="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html" rel="ugc nofollow">Overlayfs documentation</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.38/209-overlayfs.patch?rev=26213" class="urlextern" title="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.38/209-overlayfs.patch?rev=26213" rel="ugc nofollow">https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.38/209-overlayfs.patch?rev=26213</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://lwn.net/Articles/447650/" class="urlextern" title="http://lwn.net/Articles/447650/" rel="ugc nofollow">Debating overlayfs</a> on LWN.net</div>
</li>
<li class="level1"><div class="li"> Was mainlined in Linux kernel 3.18</div>
</li>
<li class="level1"><div class="li"> Overlayfs&#039;s support for inotify mechanisms is not complete yet. Events like IN_CLOSE_WRITE cannot be notified to listening process.</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;OverlayFS&quot;,&quot;hid&quot;:&quot;overlayfs&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;612-1233&quot;} -->
<h3 class="sectionedit4" id="tmpfs">tmpfs</h3>
<div class="level3">

<p>
<a href="https://en.wikipedia.org/wiki/tmpfs" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/tmpfs">tmpfs</a> is implemented on many Unix-like operating systems (including OpenWrt). It operates similar to a RAM-Disk, without writing files to disk. In OpenWrt, <code>/tmp</code> resides on a tmpfs-partition and <code>/var</code> is a symlink to it; <code>/dev</code> resides on a little tmpfs partition of its own.
</p>
<ul>
<li class="level1"><div class="li"> <a href="https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html" class="urlextern" title="https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html" rel="ugc nofollow">Kernel documentation on tmpfs</a></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> (+) doesn&#039;t directly use space on non-volatile storage</div>
</li>
<li class="level1"><div class="li"> (-) no wear leveling</div>
</li>
<li class="level1"><div class="li"> (-) volatile (doesn&#039;t survive a reboot)</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;tmpfs&quot;,&quot;hid&quot;:&quot;tmpfs&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:4,&quot;range&quot;:&quot;1234-1771&quot;} -->
<h3 class="sectionedit5" id="squashfs">SquashFS</h3>
<div class="level3">

<p>
<a href="https://en.wikipedia.org/wiki/SquashFS" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/SquashFS">SquashFS</a> is a <em>read only</em> compressed filesystem. While <a href="https://en.wikipedia.org/wiki/gzip" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/gzip">gzip</a> is available, at OpenWrt it uses <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm">LZMA</a> for the compression. Since SquashFS is a read only filesystem, it doesn&#039;t need to align the data, allowing it to pack the files tighter thus taking up significantly less space than JFFS2 (20-30% savings over a JFFS2 filesystem)!
</p>
<ul>
<li class="level1"><div class="li"> (+) taking up as little space as possible</div>
</li>
<li class="level1"><div class="li"> (+) allowing the implementation of an idiot proof <a href="/docs/guide-user/troubleshooting/failsafe_and_factory_reset" class="wikilink1" title="docs:guide-user:troubleshooting:failsafe_and_factory_reset" data-wiki-id="docs:guide-user:troubleshooting:failsafe_and_factory_reset">FailSafe</a> for recovery, since it is not possible to write to it</div>
</li>
<li class="level1"><div class="li"> (-) read only</div>
</li>
<li class="level1"><div class="li"> (-) waste space, since each time a file contained on it is modified, actually a copy of it is being copied to the second (JFFS2) partition</div>
</li>
<li class="level1"><div class="li"> <a href="https://www.kernel.org/doc/html/latest/filesystems/squashfs.html" class="urlextern" title="https://www.kernel.org/doc/html/latest/filesystems/squashfs.html" rel="ugc nofollow">Kernel documentation on SquashFS</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://elinux.org/Squash_Fs_Comparisons" class="urlextern" title="https://elinux.org/Squash_Fs_Comparisons" rel="ugc nofollow">SquashFs Performance Comparisons</a></div>
</li>
</ul>

<p>
There is a generic problem when running SquashFS on NAND: The issue is that SquashFS has no bad block management at all and requires all blocks on order; but for proper NAND bad block management you also need to be able to skip bad blocks and occasionally relocate blocks (see <a href="https://www.infradead.org/pipermail/linux-mtd/2006-April/015386.html" class="urlextern" title="https://www.infradead.org/pipermail/linux-mtd/2006-April/015386.html" rel="ugc nofollow">squashfs and NAND flash</a>). That&#039;s why raw SquashFS is a bad idea on NAND (it works if you use a FTL like UBIFS).
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;SquashFS&quot;,&quot;hid&quot;:&quot;squashfs&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;1772-3218&quot;} -->
<h3 class="sectionedit6" id="jffs2">JFFS2</h3>
<div class="level3">

<p>
<a href="https://en.wikipedia.org/wiki/JFFS2" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/JFFS2">JFFS2</a> is a <em>writable</em> compressed filesystem with <em><a href="https://en.wikipedia.org/wiki/Journaling file system" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Journaling file system">journaling</a></em> and <em><a href="https://en.wikipedia.org/wiki/wear leveling" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/wear leveling">wear leveling</a></em> using <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm">LZMA</a> for the compression.
</p>
<ul>
<li class="level1"><div class="li"> (+) is writable, has journaling and wear leveling</div>
</li>
<li class="level1"><div class="li"> (+) is cool</div>
</li>
<li class="level1"><div class="li"> (-) is compressed, so a program (<code><a href="/docs/guide-user/additional-software/opkg" class="wikilink1" title="docs:guide-user:additional-software:opkg" data-wiki-id="docs:guide-user:additional-software:opkg">opkg</a></code> in particular) cannot know in advance how much space a package will occupy</div>
</li>
<li class="level1"><div class="li"> (+) is compressed, so a program (which is preinstalled) takes much less space, so effectively you have more space</div>
</li>
</ul>

<p>
For NAND-flash targets, it was replaced with UBIFS.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;JFFS2&quot;,&quot;hid&quot;:&quot;jffs2&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:6,&quot;range&quot;:&quot;3219-3847&quot;} -->
<h3 class="sectionedit7" id="ubifs">UBIFS</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/UBIFS" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/UBIFS">UBIFS</a> is a file system for <a href="/docs/techref/flash.layout" class="wikilink1" title="docs:techref:flash.layout" data-wiki-id="docs:techref:flash.layout">raw flash</a>. It is used in OpenWrt NAND targets since :<img src="/lib/images/smileys/fixme.svg" class="icon smiley" alt="FIXME" />: around r40364</div>
</li>
<li class="level1"><div class="li"> <a href="https://www.kernel.org/doc/html/latest/filesystems/ubifs.html" class="urlextern" title="https://www.kernel.org/doc/html/latest/filesystems/ubifs.html" rel="ugc nofollow">Kernel documentation on UBIFS</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://lwn.net/Articles/704261/" class="urlextern" title="https://lwn.net/Articles/704261/" rel="ugc nofollow">UBIFS File Encryption</a> how does UBIFS understand what a “file” is? Isn&#039;t a file</div>
</li>
<li class="level1"><div class="li"> <a href="https://lwn.net/Articles/706338/" class="urlextern" title="https://lwn.net/Articles/706338/" rel="ugc nofollow">UBIFS File Encryption v1</a> on LWN.net</div>
</li>
<li class="level1"><div class="li"> <a href="https://lwn.net/Articles/707900/" class="urlextern" title="https://lwn.net/Articles/707900/" rel="ugc nofollow">UBIFS File Encryption v2</a> on LWN.net</div>
</li>
<li class="level1"><div class="li"> <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=UBI-UBIFS-Linux-4.9" class="urlextern" title="https://www.phoronix.com/scan.php?page=news_item&amp;px=UBI-UBIFS-Linux-4.9" rel="ugc nofollow">UBIFS Supports OverlayFS In Linux 4.9, Readying UBI For MLC Support</a></div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;UBIFS&quot;,&quot;hid&quot;:&quot;ubifs&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:7,&quot;range&quot;:&quot;3848-4528&quot;} -->
<h3 class="sectionedit8" id="ext2">ext2</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/ext2" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/ext2">ext2</a></div>
</li>
<li class="level1"><div class="li"> Ext2/3/4 is used on x86, x86-64 and for some arch with SD-card rootfs</div>
</li>
<li class="level1"><div class="li"> <a href="https://www.kernel.org/doc/html/latest/filesystems/ext2.html" class="urlextern" title="https://www.kernel.org/doc/html/latest/filesystems/ext2.html" rel="ugc nofollow">Kernel documentation on ext2</a></div>
</li>
<li class="level1"><div class="li"> (+) a program (<code><a href="/docs/guide-user/additional-software/opkg" class="wikilink1" title="docs:guide-user:additional-software:opkg" data-wiki-id="docs:guide-user:additional-software:opkg">opkg</a></code> in particularly) knows how much space is left!</div>
</li>
<li class="level1"><div class="li"> (+) good ol&#039; veteran <abbr title="Free &amp; Open-Source Software">FOSS</abbr> file system</div>
</li>
<li class="level1"><div class="li"> (-) no journaling (ext3, ext4 support journaling)</div>
</li>
<li class="level1"><div class="li"> (-) no wear leveling</div>
</li>
<li class="level1"><div class="li"> (-) no transparent compression</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;ext2&quot;,&quot;hid&quot;:&quot;ext2&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:8,&quot;range&quot;:&quot;4529-5005&quot;} -->
<h2 class="sectionedit9" id="other_filesystems">Other filesystems</h2>
<div class="level2">

<p>
OpenWrt does not use other filesystems as rootfs. It supports several filesystems attached to via various mechanisms like USB, SATA or network. For a list see <a href="/docs/guide-user/storage/start" class="wikilink1" title="docs:guide-user:storage:start" data-wiki-id="docs:guide-user:storage:start">storage</a>.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Other filesystems&quot;,&quot;hid&quot;:&quot;other_filesystems&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:9,&quot;range&quot;:&quot;5006-5231&quot;} -->
<h3 class="sectionedit10" id="mini_fo">mini_fo</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> was used by older OpenWrt version and thus there are still references to this in the Wiki</div>
</li>
<li class="level1"><div class="li"> replaced by <a href="#overlayfs" title="docs:techref:filesystems ↵" class="wikilink1">OverlayFS</a> now.</div>
</li>
<li class="level1"><div class="li"> <a href="https://lwn.net/Articles/135283" class="urlextern" title="https://lwn.net/Articles/135283" rel="ugc nofollow">The mini_fo filesystem</a> on LWN.net</div>
</li>
<li class="level1"><div class="li"> <a href="https://www.denx.de/wiki/bin/view/Know/MiniFOHome" class="urlextern" title="https://www.denx.de/wiki/bin/view/Know/MiniFOHome" rel="ugc nofollow">mini_fo: The mini fanout overlay file system</a> official site</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;mini_fo&quot;,&quot;hid&quot;:&quot;mini_fo&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:10,&quot;range&quot;:&quot;5232-5572&quot;} -->
<h2 class="sectionedit11" id="implementation_in_openwrt">Implementation in OpenWrt</h2>
<div class="level2">

<p>
The <a href="/docs/techref/flash.layout" class="wikilink1" title="docs:techref:flash.layout" data-wiki-id="docs:techref:flash.layout">flash.layout</a> article documents how OpenWrt uses both SquashFS and JFFS2 filesystems combined into one filesystem by overlayfs. The kernel is also stored separately from these partitions in raw flash. When the kernel is built, it is also compressed with <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm">LZMA</a> and <a href="https://en.wikipedia.org/wiki/gzip" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/gzip">gzip</a>, as documented in <a href="/docs/guide-user/additional-software/imagebuilder" class="wikilink1" title="docs:guide-user:additional-software:imagebuilder" data-wiki-id="docs:guide-user:additional-software:imagebuilder">imagebuilder</a>.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Implementation in OpenWrt&quot;,&quot;hid&quot;:&quot;implementation_in_openwrt&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:11,&quot;range&quot;:&quot;5573-6023&quot;} -->
<h3 class="sectionedit12" id="boot_process">Boot process</h3>
<div class="level3">

<p>
System bootup is as follows: →<a href="/docs/techref/process.boot" class="wikilink1" title="docs:techref:process.boot" data-wiki-id="docs:techref:process.boot">process.boot</a>
</p>
<ol>
<li class="level1"><div class="li"> kernel boots from a known raw partition (without a FS), scans mtd partition <em>rootfs</em> for a valid superblock and mounts the SquashFS partition (containing <code>/etc</code>) then runs <code><a href="/docs/guide-user/base-system/notuci.config#etcpreinit" class="wikilink1" title="docs:guide-user:base-system:notuci.config" data-wiki-id="docs:guide-user:base-system:notuci.config">/etc/preinit</a></code>. (More info at <a href="/docs/techref/filesystems#technicaldetails" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">technical.details</a>)</div>
</li>
<li class="level1"><div class="li"> <code>/etc/preinit</code> runs <code><a href="https://dev.openwrt.org/browser/trunk/package/base-files/files/sbin/mount_root" class="urlextern" title="https://dev.openwrt.org/browser/trunk/package/base-files/files/sbin/mount_root" rel="ugc nofollow">/sbin/mount_root</a></code></div>
</li>
<li class="level1"><div class="li"> <code>mount_root</code> mounts the JFFS2 partition (<code>/overlay</code>) and <strong>combines</strong> it with the SquashFS partition (<code>/rom</code>) to create a new <em>virtual root filesystem</em> (<code>/</code>)</div>
</li>
<li class="level1"><div class="li"> bootup continues with <code>/sbin/init</code></div>
</li>
</ol>

<p>
<code>/overlay</code> was previously named <code>/jffs2</code>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Boot process&quot;,&quot;hid&quot;:&quot;boot_process&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:12,&quot;range&quot;:&quot;6024-6800&quot;} -->
<h3 class="sectionedit13" id="explanations">Explanations</h3>
<div class="level3">
<div class="table sectionedit14"><table class="inline">
	<tr class="row0">
		<td class="col0"> <img src="/lib/images/smileys/fixme.svg" class="icon smiley" alt="FIXME" />: Please feel free to merge Explanation 1 with Explanation 2 </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table&quot;,&quot;secid&quot;:14,&quot;range&quot;:&quot;6825-6894&quot;} -->
</div>

<h4 id="explanations_1">Explanations 1</h4>
<div class="level4">

<p>
Both SquashFS and JFFS2 are compressed filesystems using <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm">LZMA</a> for the compression. SquashFS is a <em>read only</em> filesystem while JFFS2 is a writable filesystem with <em>journaling</em> and <em>wear leveling</em>.<br/>

Our job when writing the firmware is to put as much common functionality on SquashFS while not wasting space with unwanted features. Additional features can always be installed onto JFFS2 by the user. The use of <code>mini_fo</code>/<code>overlayfs</code> means that the filesystem is presented as one large writable filesystem to the user with no visible boundary between SquashFS and JFFS2 -- files are simply copied to JFFS2 when they&#039;re written.<br/>

It&#039;s not all without side effects however.<br/>

The fact that we pack things so tightly in flash means that if the firmware ever changes, the size and location of the JFFS2 partition also changes, potentially wiping out a large chunk of JFFS2 data and corrupting the filesystem. To deal with this, we&#039;ve implemented a policy that after each reflash the JFFS2 data is reformatted. The trick to doing that is a special value, <code>0xdeadc0de</code>; when this value appears in a JFFS2 partition, everything from that point to the end of the partition is wiped. So, hidden at the end of the firmware images, is the value 0xdeadcode, positioned such that it becomes the start of the JFFS2 partition.<br/>

The fact that we use a combination of compressed and partially read only filesystems also has an interesting effect on package management:<br/>

In particular, you need to be careful what packages you update. While <code><a href="/docs/guide-user/additional-software/opkg" class="wikilink1" title="docs:guide-user:additional-software:opkg" data-wiki-id="docs:guide-user:additional-software:opkg">opkg</a></code> is more than happy to install an updated package on JFFS2, it&#039;s unable to remove the original package from SquashFS; the end result is that you slowly start using more and more space until the JFFS2 partition is filled. The opkg util really has no idea how much space is available on the JFFS2 partition since it&#039;s compressed, and so it will blindly keep going until the opkg system crashes -- at that point you have so little space you probably can&#039;t even use opkg to remove anything.
</p>

</div>

<h4 id="explanation_2">Explanation 2</h4>
<div class="level4">

<p>
On many embedded targets that use  <a href="https://en.wikipedia.org/wiki/Flash_memory#NOR_flash" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Flash_memory#NOR_flash">NOR flash</a> for the root filesystem, OpenWrt implements a clever trick to get the most out of the limited flash memory capacity while retaining flexibility for the end-user:<br/>

Basically, during the image creation, all of the rootfs contents is packed up in a SquashFS filesystem -- a highly efficient filesystem with compression support. There&#039;s one important detail about it though: it is a read-only filesystem. To overcome this limitation OpenWrt uses the remaining portion of the NOR rootfs partition to store an additional read/write jffs2 filesystem which is “overlayed” on top of the rootfs (that is, allowing to read unchanged files from the SquashFS but storing all the modifications made to the jffs2 part).<br/>

This design has another important advantage for the end-user: even when the read/write partition is in total mess, he can always boot to the failsafe mode (which mounts only the squashfs part) and proceed
from there.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Explanations&quot;,&quot;hid&quot;:&quot;explanations&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:13,&quot;range&quot;:&quot;6801-10059&quot;} -->
<h3 class="sectionedit15" id="technical_details">Technical Details</h3>
<div class="level3">

<p>
The kernel boot process involves discovering of partitions within the NOR flash and it can be done by various target-dependent means:
</p>
<ul>
<li class="level1"><div class="li"> some bootloaders store a partition table at a known location</div>
</li>
<li class="level1"><div class="li"> some pass the partition layout via kernel command line</div>
</li>
<li class="level1"><div class="li"> some targets require specifying the kernel command line at the compile time (thus overriding the one provided by the bootloader).</div>
</li>
</ul>

<p>
Either way, if there is a partition named <code>rootfs</code> and <code>MTD_ROOTFS_ROOT_DEV</code> kernel config option is set to <code>yes</code>, this partition is automatically used for the root filesystem.
</p>

<p>
After that, if <code>MTD_ROOTFS_SPLIT</code> is enabled, the kernel adjusts the <code>rootfs</code> partition size to the minimum required by the particular SquashFS image and automatically adds <code>rootfs_data</code> to the list of the available mtd partitions setting its beginning to the first appropriate address after the SquashFS end and size to the remainder of the original <code>rootfs</code> partition. The resulting list is stored in RAM only, so no partition table of any kind gets actually modified.
</p>

<p>
For more details please refer to the actual patch at:
<a href="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/065-rootfs_split.patch" class="urlextern" title="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/065-rootfs_split.patch" rel="ugc nofollow">https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/065-rootfs_split.patch</a>
</p>

<p>
For overlaying a special <code>mini_fo</code> filesystem is used, the <code>README</code> is available from the sources at
<a href="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/209-mini_fo.patch" class="urlextern" title="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/209-mini_fo.patch" rel="ugc nofollow">https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/209-mini_fo.patch</a>
</p>

</div>

<h4 id="can_we_switch_the_filesystem_to_be_entirely_jffs2">Can we switch the filesystem to be entirely JFFS2?</h4>
<div class="level4">

<p>
<strong><em><code>Note:</code></em></strong>: It is possible to contain the entire root filesystem on a JFFS2-Partition only, instead of a combination of both.
The advantage is that changes to included files no longer leaves behind an old copy on the read only filesystem. So you could end up saving space.
The disadvantage of this would be, that you have no failsafe any longer and also, JFFS2 takes significantly more space then SquashFS.
</p>

<p>
Yes, it&#039;s technically possible, but a bit of a mess to actually pull off. The firmware has to be loaded as a trx file, which means that you have to put the JFFS2 data inside of the trx. But, as I said above, the trx has a checksum, meaning that if you ever change that data, you invalidate the checksum. The solution is that you install with the JFFS2 data contained within the trx, and then change the trx-boundaries at runtime. The end result is a single JFFS2 partition for the root filesystem. Why someone would want to do it is beyond me; it takes more space, and while it would allow you to upgrade the contents of the filesystem you would still be unable to replace the kernel (outside of the filesystem), meaning that a seamless upgrade between releases is still not possible! Having SquashFS gives you a failsafe mechanism where you can always ignore the JFFS2 partition and boot directly off SquashFS, or restore files to their original SquashFS versions.
</p>

<p>
I used to have a trick where I could convert a SquashFS install to a JFFS2 install at runtime by copying all the data onto the SquashFS partition and changing the partition boundaries. I never really had much use for the util -- not to mention it required a rather large flash to store both SquashFS and JFFS2 copies of the root during transition -- so support for it was dropped.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Technical Details&quot;,&quot;hid&quot;:&quot;technical_details&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:15,&quot;range&quot;:&quot;10060-13330&quot;} -->
<h2 class="sectionedit16" id="notes">Notes</h2>
<div class="level2">

<p>
Example pictures: on formatted partition / how data is stored (and addressed on ext3)
</p>
<ul>
<li class="level1"><div class="li"> how data is stored and addressed by ext2:</div>
</li>
<li class="level1"><div class="li"> how data is stored and addressed by ext3:</div>
</li>
<li class="level1"><div class="li"> how data is stored and addressed by SquashFS:</div>
</li>
<li class="level1"><div class="li"> how data is stored and addressed by JFFS2:</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Notes&quot;,&quot;hid&quot;:&quot;notes&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:16,&quot;range&quot;:&quot;13331-&quot;} -->