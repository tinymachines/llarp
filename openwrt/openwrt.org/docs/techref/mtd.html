<div class="table sectionedit1"><table class="inline">
	<tr class="row0">
		<td class="col0"> <img src="/lib/images/smileys/fixme.svg" class="icon smiley" alt="FIXME" /> This page is a Work In Progress. The goal is to make it similar to <a href="/docs/guide-user/additional-software/opkg" class="wikilink1" title="docs:guide-user:additional-software:opkg" data-wiki-id="docs:guide-user:additional-software:opkg">opkg</a> and then link to it as often as possible </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table&quot;,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-163&quot;} -->
<h1 class="sectionedit2" id="mtd">MTD</h1>
<div class="level1">

<p>
<code>mtd</code> is a utility we use to write to an MTD (Memory Technology Device). Please read the <a href="#notes" title="docs:techref:mtd ↵" class="wikilink1">Notes</a> to learn more.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;MTD&quot;,&quot;hid&quot;:&quot;mtd&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;165-299&quot;} -->
<h2 class="sectionedit3" id="invocation">Invocation</h2>
<div class="level2">
<pre class="code">Usage: mtd [&lt;options&gt; ...] &lt;command&gt; [&lt;arguments&gt; ...] &lt;device&gt;[:&lt;device&gt;...]</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Invocation&quot;,&quot;hid&quot;:&quot;invocation&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;300-416&quot;} -->
<h3 class="sectionedit4" id="writing_to_mtd">Writing to MTD</h3>
<div class="level3">
<div class="table sectionedit5"><table class="inline">
	<tr class="row0">
		<td class="col0 leftalign"> <code><strong>unlock</strong> &lt;dev&gt;</code>        </td><td class="col1 leftalign"> unlock the device  </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> <code><strong>refresh</strong> &lt;dev&gt;</code>       </td><td class="col1 leftalign"> refresh mtd partition  </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> <code><strong>erase</strong> &lt;dev&gt;</code>         </td><td class="col1 leftalign"> erase all data on device  </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <code><strong>write</strong> &lt;imagefile&gt;|-</code> </td><td class="col1 leftalign"> write &lt;imagefile&gt; (use - for stdin) to device  </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> <code><strong>jffs2write</strong> &lt;file&gt;</code>   </td><td class="col1 leftalign"> append &lt;file&gt; to the jffs2 partition on the device  </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> <code><strong>fixtrx</strong> &lt;dev&gt;</code>        </td><td class="col1 leftalign"> fix the checksum in a trx header on first boot  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table1&quot;,&quot;secid&quot;:5,&quot;range&quot;:&quot;442-860&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Writing to MTD&quot;,&quot;hid&quot;:&quot;writing_to_mtd&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:4,&quot;range&quot;:&quot;417-861&quot;} -->
<h3 class="sectionedit6" id="options">Options</h3>
<div class="level3">
<div class="table sectionedit7"><table class="inline">
	<tr class="row0">
		<td class="col0 leftalign"> <code><strong>-q</strong></code>                     </td><td class="col1 leftalign"> quiet mode (once: no [w] on writing, twice: no status messages)  </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> <code><strong>-n</strong></code>                     </td><td class="col1 leftalign"> write without first erasing the blocks  </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> <code><strong>-r</strong></code>                     </td><td class="col1 leftalign"> reboot after successful command  </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> <code><strong>-f</strong></code>                     </td><td class="col1 leftalign"> force write without trx checks  </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> <code><strong>-e &lt;device&gt;</strong></code>            </td><td class="col1 leftalign"> erase &lt;device&gt; before executing the command  </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> <code><strong>-d &lt;name&gt;</strong></code>              </td><td class="col1 leftalign"> directory for jffs2write, defaults to “tmp”  </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> <code><strong>-j &lt;name&gt;</strong></code>              </td><td class="col1 leftalign"> integrate &lt;file&gt; into jffs2 data when writing an image  </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> <code><strong>-o offset</strong></code>              </td><td class="col1 leftalign"> offset of the image header in the partition(for fixtrx)  </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> <code><strong>-F &lt;part&gt;[:&lt;size&gt;[:&lt;entrypoint&gt;]][,&lt;part&gt;...]</strong></code>  </td><td class="col1 leftalign"> alter the fis partition table to create new partitions replacing the partitions provided as argument to the write command (only valid together with the write command)  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table2&quot;,&quot;secid&quot;:7,&quot;range&quot;:&quot;880-1777&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Options&quot;,&quot;hid&quot;:&quot;options&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:6,&quot;range&quot;:&quot;862-1778&quot;} -->
<h2 class="sectionedit8" id="examples">Examples</h2>
<div class="level2">

<p>
Download <code>linux.bin</code> from Internet (it&#039;s not safe to do so, here is for demonstration purpose only), then write <code>linux.bin</code> to a MTD partition labeled as <code>linux</code> (could be <code>mtd4</code>) and reboot afterwards:
</p>
<pre class="code">cd /tmp
wget http://www.example.org/linux.bin
mtd -r write /tmp/linux.bin linux</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Examples&quot;,&quot;hid&quot;:&quot;examples&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:8,&quot;range&quot;:&quot;1779-2106&quot;} -->
<h2 class="sectionedit9" id="example_flash_u-boot_from_openwrt">Example (flash u-boot from OpenWrt)</h2>
<div class="level2">

<p>
Tested  on Marvell EspressoBinBoard based on MVEBU, (see <a href="https://forum.openwrt.org/t/is-it-possible-to-flash-u-boot-from-openwrt/90284" class="urlextern" title="https://forum.openwrt.org/t/is-it-possible-to-flash-u-boot-from-openwrt/90284" rel="ugc nofollow">forum topic</a>)
Download <code>flash-image.bin</code> for your specific hardware from <a href="https://downloads.openwrt.org/snapshots/targets/mvebu/cortexa53/" class="urlextern" title="https://downloads.openwrt.org/snapshots/targets/mvebu/cortexa53/" rel="ugc nofollow">SnapShots</a>
</p>

<p>
You can checks your mtd partitions from proc : 
</p>
<pre class="code">root@EBIN:~# cat /proc/mtd 
dev:    size   erasesize  name
mtd0: 003f0000 00010000 &quot;firmware&quot;
mtd1: 00010000 00010000 &quot;u-boot-env&quot;
</pre>

<p>
(it&#039;s not safe to do so, here is for demonstration purpose only), 
</p>

<p>
then write <code>flash-image.bin</code> to a MTD partition labeled as <code>spi0.0</code> (could be <code>mtd0</code> or <code>firmware</code>) and reboot afterwards :
</p>
<pre class="code">cd /tmp
wget https://downloads.openwrt.org/snapshots/targets/mvebu/cortexa53/trusted-firmware-a-espressobin-v7-1gb/flash-image.bin
mtd -r write /tmp/flash-image.bin /dev/mtd0</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Example (flash u-boot from OpenWrt)&quot;,&quot;hid&quot;:&quot;example_flash_u-boot_from_openwrt&quot;,&quot;codeblockOffset&quot;:2,&quot;secid&quot;:9,&quot;range&quot;:&quot;2107-3035&quot;} -->
<h2 class="sectionedit10" id="mtd_vs_dd">mtd vs dd</h2>
<div class="level2">

<p>
The differences between <code><a href="http://linux.die.net/man/1/dd" class="urlextern" title="http://linux.die.net/man/1/dd" rel="ugc nofollow">dd</a></code> (disc dump) and <code>mtd</code> are ... 
TODO
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;mtd vs dd&quot;,&quot;hid&quot;:&quot;mtd_vs_dd&quot;,&quot;codeblockOffset&quot;:4,&quot;secid&quot;:10,&quot;range&quot;:&quot;3036-3161&quot;} -->
<h2 class="sectionedit11" id="mtd_on_vendor-firmware">mtd on vendor-firmware</h2>
<div class="level2">

<p>
<code>mtd</code> can even be used with vendor-firmware, as long as the kernel had mtd-support and not using something “home-brewed”. When the vendor is not shipping the binary it can probably transferred via <code>scp</code>, <code>netcat</code>, <code>tftp</code>, <code>ftp</code>, <code>http</code>onto the board. The original binary from the OpenWrt-package might not run on the vendor-os, but linking it static should do the trick. 
With OpenWrt-21.02 I was using a small hack to to let the buildroot create a static binary:
</p>
<pre class="code">sed -i -e &quot;s/^LDFLAGS += /LDFLAGS += -static /&quot; package/system/mtd/src/Makefile
make package/mtd/compile</pre>

<p>
This patches the mtd source to include the “-static” option when building the binary. This way the binary gets all dependent library-code embedded to make it run itself, as long as the correct CPU-target is used. The new binary can be extracted from the resulting package or just copied from <code>build_dir/target-&lt;ARCH&gt;/linux-&lt;TARGET&gt;-&lt;SUBTARGET&gt;/mtd</code>.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;mtd on vendor-firmware&quot;,&quot;hid&quot;:&quot;mtd_on_vendor-firmware&quot;,&quot;codeblockOffset&quot;:4,&quot;secid&quot;:11,&quot;range&quot;:&quot;3162-4147&quot;} -->
<h2 class="sectionedit12" id="notes">Notes</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="/docs/techref/flash" class="wikilink1" title="docs:techref:flash" data-wiki-id="docs:techref:flash">Flash memory - things to consider</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://en.wikipedia.org/wiki/Memory Technology Device" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Memory Technology Device">MTD (Memory Technology Device)</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://www.linux-mtd.infradead.org/doc/general.html" class="urlextern" title="http://www.linux-mtd.infradead.org/doc/general.html" rel="ugc nofollow">documentation on MTDs</a>.</div>
</li>
<li class="level1"><div class="li"> <a href="http://www.linux-mtd.infradead.org/faq/general.html#L_mtd_vs_hdd" class="urlextern" title="http://www.linux-mtd.infradead.org/faq/general.html#L_mtd_vs_hdd" rel="ugc nofollow">The differences between flash devices and block drives in a table</a></div>
</li>
<li class="level1 node"><div class="li"> To make it more clear, here is a small <a href="http://lxr.free-electrons.com/source/Documentation/filesystems/ubifs.txt" class="urlextern" title="http://lxr.free-electrons.com/source/Documentation/filesystems/ubifs.txt" rel="ugc nofollow">comparison of MTD devices and block devices</a>:</div>
<ul>
<li class="level2"><div class="li"> MTD devices represent flash devices and they consist of eraseblocks of rather large size, typically about 128KiB. Block devices consist of small blocks, typically 512 bytes. MTD devices support 3 main operations - read from some offset within an eraseblock, write to some offset within an eraseblock, and erase a whole eraseblock. Block  devices support 2 main operations - read a whole block and write a whole block.</div>
</li>
<li class="level2"><div class="li"> The whole eraseblock has to be erased before it becomes possible to re-write its contents. Blocks may be just re-written.</div>
</li>
<li class="level2"><div class="li"> Eraseblocks become worn out after some number of erase cycles - typically 100K-1G for SLC NAND and NOR flashes, and 1K-10K for MLC NAND flashes. Blocks do not have the wear-out property.</div>
</li>
<li class="level2"><div class="li"> Eraseblocks may become bad (only on NAND flashes) and software should deal with this. Blocks on hard drives typically do not become bad, because hardware has mechanisms to substitute bad blocks, at least in modern LBA disks.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Sometimes flash memory uses FTL:  <a href="http://www.linux-mtd.infradead.org/doc/ubifs.html#L_raw_vs_ftl" class="urlextern" title="http://www.linux-mtd.infradead.org/doc/ubifs.html#L_raw_vs_ftl" rel="ugc nofollow">Raw Flash vs. FTL (Flash Translation Layer)</a></div>
</li>
<li class="level1"><div class="li"> Although most flashes on the commodity hardware have FTL, there are systems which have <strong>bare flashes and do not use FTL</strong>! Those are mostly various handheld devices and <strong>embedded systems</strong>.</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Notes&quot;,&quot;hid&quot;:&quot;notes&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:12,&quot;range&quot;:&quot;4148-&quot;} -->