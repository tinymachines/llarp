
<h1 class="sectionedit1" id="the_openwrt_flash_layout">The OpenWrt Flash Layout</h1>
<div class="level1">

<p>
The embedded devices (routers and such) OpenWrt/LEDE (Linux Embedded Development Environment) has mainly targeted since its inception, use flash memory as the form of non-volatile memory for the persistent storage of the firmware and its configuration.<br/>

</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;The OpenWrt Flash Layout&quot;,&quot;hid&quot;:&quot;the_openwrt_flash_layout&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-295&quot;} -->
<h2 class="sectionedit2" id="types_of_flash_memory">Types of flash memory</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Types of flash memory&quot;,&quot;hid&quot;:&quot;types_of_flash_memory&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;296-330&quot;} -->
<h3 class="sectionedit3" id="non-mechanical_wear">Non-mechanical wear</h3>
<div class="level3">

<p>
Moving parts are prone to <a href="https://en.wikipedia.org/wiki/wear" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/wear">wear</a> (german: <a href="https://de.wikipedia.org/wiki/Verschleiß" class="interwiki iw_wpde" title="https://de.wikipedia.org/wiki/Verschleiß">Verschleiß</a>) and experience all sorts of “mechanical breakage/mechanical failure”. But how can a non-moving part possibly break? Possibly by <a href="https://en.wikipedia.org/wiki/electromigration" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/electromigration">electromigration</a>, by <a href="https://en.wikipedia.org/wiki/Whisker (metallurgy)" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Whisker (metallurgy)">whisker growth</a>, etc.
</p>

<p>
Non-mechanical wear does not only occur when flash memory is erased!
</p>
<div class="table sectionedit4"><table class="inline">
	<tr class="row0">
		<td class="col0"> <img src="/_media/meta/icons/tango/dialog-information.png" class="media" loading="lazy" alt="" /> </td><td class="col1"> 1. Flash memory is more likely to experience failure than a <a href="https://en.wikipedia.org/wiki/Hard_disk_drive" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Hard_disk_drive">Hard_disk_drive</a> (the ones with the platters rotating at 5400–15000 <a href="https://en.wikipedia.org/wiki/Revolutions per minute" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Revolutions per minute">RPM</a>)<br/>
2. Some types of flash memory seem to experience more non-mechanical wear then other types<br/>
3. How do we deal with failure? </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table&quot;,&quot;secid&quot;:4,&quot;range&quot;:&quot;706-1061&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Non-mechanical wear&quot;,&quot;hid&quot;:&quot;non-mechanical_wear&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;331-1063&quot;} -->
<h3 class="sectionedit5" id="host-managed_vs_self-managed">Host-managed vs. self-managed</h3>
<div class="level3">

<p>
Based on how the flash memory chip is connected with the <a href="/docs/techref/hardware/soc" class="wikilink1" title="docs:techref:hardware:soc" data-wiki-id="docs:techref:hardware:soc">SoC</a> (i.e. the “host”) we at OpenWrt distinguish between <strong><em>“raw flash”</em></strong> or <strong><em>“host-managed”</em></strong> and <strong><em>“FTL (Flash Translation Layer) flash”</em></strong> or <strong><em>“self-managed”</em></strong>: in case the flash memory chip is connected directly with the SoC we call it “raw flash” / “host-managed” and in case there is an additional controller chip between the flash memory chip and the SoC, we call it “FTL flash” / “self-managed”. Primarily the controller chip does <a href="https://en.wikipedia.org/wiki/wear-leveling" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/wear-leveling">wear-leveling</a> and manages known bad blocks, but it may do other stuff as well. The flash memory cannot be accessed directly, but only through this controller. The controller has to be considered a <a href="https://en.wikipedia.org/wiki/black box" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/black box">black box</a>.
</p>
<div class="table sectionedit6"><table class="inline">
	<tr class="row0">
		<td class="col0"> <img src="/_media/meta/icons/tango/dialog-information.png" class="media" loading="lazy" alt="" /> </td><td class="col1"> Embedded systems almost exclusively use “raw flash”, while <a href="https://en.wikipedia.org/wiki/Solid-state drive" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Solid-state drive">solid-state drives (SSDs)</a> and USB memory sticks, almost exclusively use “FTL flash”!<br/>
</td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table1&quot;,&quot;secid&quot;:6,&quot;range&quot;:&quot;1868-2096&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Host-managed vs. self-managed&quot;,&quot;hid&quot;:&quot;host-managed_vs_self-managed&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;1064-2098&quot;} -->
<h3 class="sectionedit7" id="nor_flash_vs_nand_flash">NOR flash vs NAND flash</h3>
<div class="level3">

<p>
Additionally we at OpenWrt distinguish between the two basic types of flash memory: <a href="https://en.wikipedia.org/wiki/Flash_memory#NOR_flash" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Flash_memory#NOR_flash">NOR flash</a> and <a href="https://en.wikipedia.org/wiki/Flash_memory#NAND_flash" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Flash_memory#NAND_flash">NAND flash</a>.<br/>

</p>

<p>
“Raw NOR flash” in typical routers is generally small (4 MiB – 16 MiB) and <em class="u">error-free</em>: all data blocks are guaranteed to work correctly. Because raw NOR flash is error-free, the installed file system(s) do not need to take bad blocks into account, and neither SquashFS nor JFFS2 do. The combination of OverlayFS with SquashFS and JFFS2 has been the default OpenWrt setup since the beginning, and it works flawlessly on “raw NOR flash”. Older routers typically use NOR flash.
</p>

<p>
“Raw NAND flash” in typical routers is generally much larger (32 MiB – 1 GiB) and <em class="u">not error-free</em>: in general the flash contains bad blocks when new and may develop more at any time. Newer routers use NAND flash because it is much cheaper for a given capacity and is also faster for bulk access (disk emulation), but at the cost of the increased complexity required to handle flash defects.
</p>

<p>
Bad blocks in NAND flash and handled in various ways:
</p>
<ul>
<li class="level1"><div class="li"> The NAND flash manufacturer guarantees that certain very small areas of the flash are defect-free. The use of such areas is up to the system designer. Some SoCs may store the first stage bootloader there (but since newer SoCs tend to support chain-of-trust booting, they typically store the first stage bootloader on-chip).</div>
</li>
<li class="level1"><div class="li"> Some partitions are used as large files that can only be read or written completely and in one go. This is the case of raw bootloaders and kernels in MTD partitions. For these partitions, bad blocks are simply skipped during both reads and writes. Because new defects almost exclusively develop during erase and writes, once written these partitions are mostly trusted to be readable forever. (But newer devices tend to duplicate these partitions to minimize failures.)</div>
</li>
<li class="level1"><div class="li"> Some partitions are used as large files that can only be written completely and in one go, but can be read in a random access fashion. This is the case of raw read-only file systems (such as squashfs) in MTD partitions. For these partitions, bad blocks are simply skipped during writes, and a kernel driver is used to read them. The driver reads the complete partition during setup skipping bad blocks, and builds a logical-block-to-flash-block table in RAM to be able to later access the partition random-access.</div>
</li>
<li class="level1 node"><div class="li"> Some large partitions are used as containers for other compartmentalized data. Note that the amount of bad blocks in a certain partition is a-priory unknown, and thus a raw partition size cannot be taken as the its usable size. For smaller partitions this effect is amplified: although there is a manufacturer-defined limit on the number of bad blocks in a flash, nothing precludes all bad blocks from residing in the same partition. Thus, for guaranteed operation, a system designer should allow <em>in each and every partition</em> the maximum number of bad blocks specified for the complete flash. (In practice though, this is almost never done.) Also note that the previous kinds of defect handling do not spread wear produced by erase/write cycles across the whole flash, and thus in general reduce the lifespan of the device. These problems are both solved by UBI. Ideally a single very large UBI partition is created that entirely manages flash defects and wear-leveling for contained volumes, and inside it different UBI volumes are created:</div>
<ul>
<li class="level2"><div class="li"> Some UBI volumes are used as large files that can only be read or written completely and in one go. This is the case of kernels in UBI partitions.</div>
</li>
<li class="level2"><div class="li"> Some UBI volumes are used as large files that can only be written completely and in one go, but can be read in a random access fashion. This is the case of read-only file systems (such as squashfs) in UBI partitions. For these volumes, an ubiblock kernel device is used to read them: the device emulates a read-only block device and maintains a logical-block-to-flash-block table in RAM to be able to access the volume random-access.</div>
</li>
<li class="level2"><div class="li"> Some UBI volumes are used as read-write filesystems. Only the UBIFS filesystem is used for this. (It would be possible to emulate read-write block devices on top of UBI and use regular filesystems on top of that, but such setups would underperfom compared to UBIFS, and it seems that the necessary UBI block emulation driver has not yet been implemented, if ever.)</div>
</li>
</ul>
</li>
</ul>

<p>
Note that because of these factors, the OpenWrt <a href="/docs/guide-user/additional-software/imagebuilder" class="wikilink1" title="docs:guide-user:additional-software:imagebuilder" data-wiki-id="docs:guide-user:additional-software:imagebuilder">Image Generator</a> has been constrained to build images that are smaller than the size of the partitions to which they are supposed to be flashed by an arbitrary margin, to maximize the probability that such images can be flashed on all devices.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;NOR flash vs NAND flash&quot;,&quot;hid&quot;:&quot;nor_flash_vs_nand_flash&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:7,&quot;range&quot;:&quot;2099-6920&quot;} -->
<h3 class="sectionedit8" id="mlc_vs_slc_flash">MLC vs. SLC flash</h3>
<div class="level3">

<p>
The main difference between SLC and MLC is durability.
<a href="https://en.wikipedia.org/wiki/Single-level cell" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Single-level cell">single-level cell (SLC)</a> flash memory may have a lifetime of about 50,000 to 100,000 program/erase cycles, while <a href="https://en.wikipedia.org/wiki/Multi-level cell" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Multi-level cell">multi-level cell (MLC)</a> flash may have a lifetime of about 1,000 to 10,000 program/erase cycles.
</p>

<p>
To be noted that it is <strong>NOT RIGHT</strong> to estimate the life of a NAND flash in embedded devices using the same method for SSD!
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;MLC vs. SLC flash&quot;,&quot;hid&quot;:&quot;mlc_vs_slc_flash&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:8,&quot;range&quot;:&quot;6921-7387&quot;} -->
<h2 class="sectionedit9" id="partitioning_of_nor_flash-based_devices">Partitioning of NOR flash-based devices</h2>
<div class="level2">

<p>
On these systems, the storage is presented by the kernel as an MTD device, and it is divided into MTD partitions. The device is not partitioned in the traditional way, where you store information about partitions in a <a href="https://en.wikipedia.org/wiki/GUID Partition Table" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/GUID Partition Table">GPT</a> or <a href="https://en.wikipedia.org/wiki/Master boot record" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Master boot record">MBR</a>. Instead, the partitioning information is directly known by the bootloader and the kernel, either through configuration, or more typically through baking it in at build time. For example, in the kernel it may simply be defined that <em>“MTD partition <strong><code>kernel</code></strong> starts at flash block <code>X</code> and consists of <code>Y</code> blocks”</em>. MTD partitions can be accessed by name or number.
</p>

<p>
The generic flash layout is:
</p>
<div class="table sectionedit10"><table class="inline">
	<tr class="row0">
		<th class="col0"> Layer0 </th><td class="col1 centeralign" colspan="6">  raw flash  </td>
	</tr>
	<tr class="row1">
		<th class="col0"> Layer1 </th><td class="col1 centeralign" rowspan="4">  bootloader <br/>
partition(s)  </td><td class="col2 centeralign" rowspan="4">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td><td class="col3 centeralign" colspan="3">  firmware partition  </td><td class="col6 centeralign" rowspan="4">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td>
	</tr>
	<tr class="row2">
		<th class="col0"> Layer2 </th><td class="col1 centeralign" colspan="2">  OpenWrt firmware image  </td><td class="col3 centeralign">  <em>(space available for storage)</em>  </td>
	</tr>
	<tr class="row3">
		<th class="col0"> Layer3 </th><td class="col1 centeralign" rowspan="2">  Linux kernel <br/>
(raw image)  </td><td class="col2 centeralign">  <strong><code>rootfs</code></strong> <br/>
mounted: “<code>/rom</code>”, <a href="/docs/techref/filesystems#squashfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">SquashFS</a> <br/>
size depends on selected packages  </td><td class="col3 centeralign">  <strong><code>rootfs_data</code></strong> <br/>
mounted: “<code>/overlay</code>”, <a href="/docs/techref/filesystems#jffs2" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">JFFS2</a> <br/>
all remaining free space  </td>
	</tr>
	<tr class="row4">
		<th class="col0"> Layer4 </th><td class="col1 centeralign" colspan="2">  mounted: “<code>/</code>”, <a href="/docs/techref/filesystems#overlayfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">OverlayFS</a> <br/>
stacking <code>/overlay</code> on top of <code>/rom</code>  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table2&quot;,&quot;secid&quot;:10,&quot;range&quot;:&quot;8129-8856&quot;} -->
<p>
Many NOR devices share this scheme, but the flash layout can differ between the devices. Please see the wiki pages for each SoC and devices for information about a particular layout. In case the flash layout differs for your device please update the wiki pages.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Partitioning of NOR flash-based devices&quot;,&quot;hid&quot;:&quot;partitioning_of_nor_flash-based_devices&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:9,&quot;range&quot;:&quot;7388-9121&quot;} -->
<h3 class="sectionedit11" id="sysupgrade_and_rootfs_data">Sysupgrade and &#039;&#039;rootfs_data&#039;&#039;</h3>
<div class="level3">

<p>
To better use the minimal storage on devices available when OpenWrt was originally being developed, the <strong><code>rootfs_data</code></strong> partition was placed immediately after the OpenWrt firmware image (which contains the kernel and rootfs), without any padding in-between. This means that during upgrades, the beginning of <strong><code>rootfs_data</code></strong> might need to be overwritten (either because the OpenWrt image grew, or because the NAND flash developed new defects in the firmware area that need to be skipped during firmware flashing).
</p>

<p>
To handle this situation, sysupgrade works in an atypical fashion. During an upgrade OpenWrt reads selected content from <strong><code>rootfs_data</code></strong> that it wants surviving the upgrade into RAM, flashes the new firmware, formats the remaining flash space as the new <strong><code>rootfs_data</code></strong> partition, and writes back the selected content to it from RAM.
</p>

<p>
Because of this, a failed sysupgrade might not only brick the device, it might also cause the contents of <strong><code>rootfs_data</code></strong> to be irrevocably lost.
</p>

<p>
Note: Arbitrary files you may choose to store in <strong><code>rootfs_data</code></strong> are by default <strong>not kept</strong> across sysupgrades (but there is a way to request future sysupgrades to conserve selected files).
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Sysupgrade and &#039;&#039;rootfs_data&#039;&#039;&quot;,&quot;hid&quot;:&quot;sysupgrade_and_rootfs_data&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:11,&quot;range&quot;:&quot;9122-10375&quot;} -->
<h3 class="sectionedit12" id="example_nor_flash_partitioning">Example NOR flash partitioning</h3>
<div class="level3">

<p>
<a href="/docs/techref/hardware/soc/soc.qualcomm" class="wikilink1" title="docs:techref:hardware:soc:soc.qualcomm" data-wiki-id="docs:techref:hardware:soc:soc.qualcomm">Qualcomm Atheros</a>-based <a href="/toh/tp-link/tl-wr1043nd" class="wikilink1" title="toh:tp-link:tl-wr1043nd" data-wiki-id="toh:tp-link:tl-wr1043nd">TL-WR1043ND</a>. Somebody also provided a <a href="https://web.archive.org/web/20131021013058/http://ubuntuone.com/2aPBH9pwkxtYzy93S0cS1z" class="urlextern" title="https://web.archive.org/web/20131021013058/http://ubuntuone.com/2aPBH9pwkxtYzy93S0cS1z" rel="ugc nofollow">LibreOffice Calc ODS</a>.
</p>

<p>
SquashFS-Images are suitable for devices with <em>“raw NOR flash memory”</em>-chips and it is not recommended to install them onto devices with <em>“raw NAND flash memory”</em>-chips. SquashFS-Images comprise both, a SquashFS partition and an JFFS2 partition. JFFS2-Images omit the SquashFS partition.
</p>
<div class="table sectionedit13"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0 centeralign" colspan="6">   TP-Link WR1043ND  Flash Layout           </th>
	</tr>
	</thead>
	<tr class="row1">
		<th class="col0 leftalign"> Layer0       </th><td class="col1 centeralign" colspan="5">                       raw NOR flash memory chip (m25p80 <a href="https://en.wikipedia.org/wiki/Serial Peripheral Interface Bus" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Serial Peripheral Interface Bus">spi</a>0.0: m25p64) 8192 KiB                                                                      </td>
	</tr>
	<tr class="row2">
		<th class="col0 leftalign"> Layer1       </th><td class="col1 centeralign">  mtd0 <strong><em>u-boot</em></strong> 128 KiB  </td><td class="col2 centeralign" colspan="3">  mtd5 <strong><em>firmware</em></strong> 8000 KiB                                      </td><td class="col5 centeralign">    mtd4 <strong><em>art</em></strong> 64 KiB  </td>
	</tr>
	<tr class="row3">
		<th class="col0 leftalign"> Layer2       </th><td class="col1 leftalign">                              </td><td class="col2 centeralign">  mtd1 <strong><em>kernel</em></strong> 1280 KiB  </td><td class="col3 centeralign" colspan="2">  mtd2 <strong><em>rootfs</em></strong> 6720 KiB                           </td><td class="col5 leftalign">          </td>
	</tr>
	<tr class="row4">
		<th class="col0 leftalign"> <span style='color:magenta; '>mountpoint</span>   </th><td class="col1 leftalign">                              </td><td class="col2 leftalign">                               </td><td class="col3 centeralign" colspan="2">  <span style='color:magenta; '><code>/</code></span>                          </td><td class="col5 leftalign">          </td>
	</tr>
	<tr class="row5">
		<th class="col0 leftalign"> filesystem   </th><td class="col1 leftalign">                              </td><td class="col2 leftalign">                               </td><td class="col3 centeralign" colspan="2">  <a href="/docs/techref/filesystems#overlayfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">OverlayFS</a>           </td><td class="col5 leftalign">          </td>
	</tr>
	<tr class="row6">
		<th class="col0 leftalign"> Layer3       </th><td class="col1 leftalign">                              </td><td class="col2 leftalign">                               </td><td class="col3 leftalign">                 </td><td class="col4 centeralign">  mtd3 <strong><em>rootfs_data</em></strong> 5184 KiB     </td><td class="col5 leftalign">          </td>
	</tr>
	<tr class="row7">
		<th class="col0 leftalign"> Size in KiB  </th><td class="col1 centeralign">  128 KiB                      </td><td class="col2 centeralign">  1280 KiB                      </td><td class="col3 centeralign">  1536 KiB        </td><td class="col4 centeralign">  5184 KiB                              </td><td class="col5 centeralign">   64 KiB  </td>
	</tr>
	<tr class="row8">
		<th class="col0 leftalign"> Name         </th><td class="col1 centeralign">  <strong><em>u-boot</em></strong>              </td><td class="col2 centeralign">  <strong><em>kernel</em></strong>               </td><td class="col3 leftalign">                 </td><td class="col4 centeralign">  <strong><em>rootfs_data</em></strong>             </td><td class="col5 centeralign">  <strong><em>art</em></strong>  </td>
	</tr>
	<tr class="row9">
		<th class="col0 leftalign"> <span style='color:magenta; '>mountpoint</span>   </th><td class="col1 centeralign">  <em>none</em>                    </td><td class="col2 centeralign">  <em>none</em>                     </td><td class="col3 centeralign">  <span style='color:magenta; '><code>/rom</code></span>  </td><td class="col4 centeralign">  <span style='color:magenta; '><code>/overlay</code></span>   </td><td class="col5 centeralign">  <em>none</em>  </td>
	</tr>
	<tr class="row10">
		<th class="col0 leftalign"> filesystem   </th><td class="col1 centeralign">  <em>none</em>                    </td><td class="col2 centeralign">  <em>none</em>                     </td><td class="col3 centeralign">  <a href="/docs/techref/filesystems#squashfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">SquashFS</a>  </td><td class="col4 centeralign">  <a href="/docs/techref/filesystems#jffs2" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">JFFS2</a>  </td><td class="col5 centeralign">  <em>none</em>  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table3&quot;,&quot;secid&quot;:13,&quot;range&quot;:&quot;10944-12680&quot;} -->
</div>

<h4 id="another_flash_layout_example">Another Flash layout example</h4>
<div class="level4">

<p>
<a href="/toh/tp-link/archer_c6_v2#flash_layout" class="wikilink1" title="toh:tp-link:archer_c6_v2" data-wiki-id="toh:tp-link:archer_c6_v2">TP-Link Archer C6 V2 (EU/RU/JP)</a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Example NOR flash partitioning&quot;,&quot;hid&quot;:&quot;example_nor_flash_partitioning&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:12,&quot;range&quot;:&quot;10376-12795&quot;} -->
<h3 class="sectionedit14" id="explanations">Explanations</h3>
<div class="level3">

<p>
The Linux kernel treats “raw flash memory” (no matter whether NOR or NAND) chips as an <a href="/docs/techref/mtd" class="wikilink1" title="docs:techref:mtd" data-wiki-id="docs:techref:mtd">MTD (Memory Technology Device)</a> and employs <a href="/docs/techref/filesystems" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">filesystems</a> developed for this purpose on top of the MTD layer.
</p>

<p>
Since the partitions are nested we look at this whole thing in layers:
</p>
<ol>
<li class="level1"><div class="li"> Layer0: So we have the Flashchip, 8 MiB in size, which is soldered to the PCB and connected to the <a href="/docs/techref/hardware/soc" class="wikilink1" title="docs:techref:hardware:soc" data-wiki-id="docs:techref:hardware:soc">soc</a> over <a href="https://en.wikipedia.org/wiki/Serial Peripheral Interface Bus" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Serial Peripheral Interface Bus">SPI (Serial Peripheral Interface Bus)</a>.</div>
</li>
<li class="level1"><div class="li"> Layer1: We “partition” the space into mtd0 for the bootloader, mtd5 for OpenWrt and, in this case, mtd4 for the ART (Atheros Radio Test) - it contains calibration data for the wifi (EEPROM). If it is missing or corrupt, <code>ath9k</code> (wireless driver) won&#039;t come up anymore. The bootloader (128 KiB) contains of the u-boot 64KiB block AND a data section which contains the MAC, WPS-PIN and type description. If no MAC is configured ath9k will not work correctly due to a faulty MAC.</div>
</li>
<li class="level1"><div class="li"> Layer2: we subdivide mtd5 (firmware) into mtd1 (kernel) and mtd2 (rootfs); In the generation process of the firmware (see <a href="/docs/guide-user/additional-software/imagebuilder" class="wikilink1" title="docs:guide-user:additional-software:imagebuilder" data-wiki-id="docs:guide-user:additional-software:imagebuilder">imagebuilder</a>) the Kernel binary file is first packed with <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm">LZMA</a>, then the obtained file is packed with <a href="https://en.wikipedia.org/wiki/gzip" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/gzip">gzip</a> and then this file will be written onto the raw flash (mtd1) without being part of any filesystem! During boot, u-boot copies this entire section into RAM and executes it. From there on, the Linux kernel bootstraps itself…</div>
</li>
<li class="level1"><div class="li"> Layer3: we subdivide rootfs even further into mtd3 for rootfs_data and the rest for an unnamed partition which will accommodate the SquashFS-partition.</div>
</li>
</ol>

</div>

<h4 id="mount_points">Mount Points</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> <span style='color:magenta; '><code>/</code></span> this is your entire root filesystem, it comprises <code>/rom</code> and <code>/overlay</code>. Please ignore <code>/rom</code> and <code>/overlay</code> and use exclusively <code>/</code> for your daily routines!</div>
</li>
<li class="level1"><div class="li"> <span style='color:magenta; '><code>/rom</code></span>  contains all the basic files, like <code>busybox</code>, <code>dropbear</code> or <code>iptables</code>. It also includes default configuration files used when booting into <a href="/docs/guide-user/troubleshooting/failsafe_and_factory_reset" class="wikilink1" title="docs:guide-user:troubleshooting:failsafe_and_factory_reset" data-wiki-id="docs:guide-user:troubleshooting:failsafe_and_factory_reset">OpenWrt Failsafe mode</a>. It does not contain the Linux kernel. All files in this directory are located on the SquashFS partition, and thus cannot be altered or deleted. But, because we use overlay_fs filesystem, <em>overlay-whiteout</em>-symlinks can be created on the JFFS2 partition.</div>
</li>
<li class="level1"><div class="li"> <span style='color:magenta; '><code>/overlay</code></span>  is the writable part of the file system that gets merged with <code>/rom</code> to create a uniform <code>/</code>-tree. It contains anything that was written to the router after <a href="/docs/guide-user/installation/generic.flashing" class="wikilink1" title="docs:guide-user:installation:generic.flashing" data-wiki-id="docs:guide-user:installation:generic.flashing">installation</a>, e.g. changed configuration files, additional packages installed with <code><a href="/docs/guide-user/additional-software/opkg" class="wikilink1" title="docs:guide-user:additional-software:opkg" data-wiki-id="docs:guide-user:additional-software:opkg">opkg</a></code>, etc. It is formatted with JFFS2.</div>
</li>
</ul>

<p>
Whenever the system is asked to look for an existing file in <code>/</code>, it first looks in <code>/overlay</code>, and if not there, then in <code>/rom</code>.  In this way <code>/overlay</code> overrides <code>/rom</code> and creates the effect of a writable <code>/</code> while much of the content is safely and efficiently stored in the read-only <code>/rom</code>.
</p>

<p>
When the system is asked to delete a file that is in <code>/rom</code>, it instead creates a corresponding entry in <code>/overlay</code>, a whiteout.  A whiteout is a symlink to <code>(overlay-whiteout)</code> that mostly behaves like a file that doesn&#039;t exist. In newer versions, the whiteout is created as a character device with 0/0 device number instead.
</p>
<pre class="code bash"><span class="co0">#!/bin/sh</span>
<span class="co0"># shows all overlay-whiteout symlinks</span>
<span class="co0"># 2018: overlay-whiteouts are a character device on CC 'find /overlay -type c' seems to work</span>
<span class="co0">#  https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt  put me on the right track</span>
&nbsp;
<span class="kw2">find</span> <span class="sy0">/</span>overlay <span class="re5">-type</span> c; <span class="kw2">find</span> <span class="sy0">/</span>overlay <span class="re5">-type</span> l <span class="re5">-exec</span> <span class="kw2">sh</span> <span class="re5">-c</span> \
    <span class="st_h">'for x; do [ &quot;$(readlink -n -- &quot;$x&quot;)&quot; = &quot;(overlay-whiteout)&quot; ] &amp;&amp; printf %s\\n &quot;$x&quot;; done'</span> <span class="re5">--</span> <span class="br0">&#123;</span><span class="br0">&#125;</span> +</pre>

</div>

<h4 id="example_2hoo_too_ht-tm02">Example 2: Hoo Too HT-TM02</h4>
<div class="level4">

<p>
<a href="/docs/techref/hardware/soc/soc.ralink" class="wikilink1" title="docs:techref:hardware:soc:soc.ralink" data-wiki-id="docs:techref:hardware:soc:soc.ralink">Ralink RT5350F</a>-based <a href="/toh/hwdata/hootoo/hootoo_tripmatenano_v15" class="wikilink1" title="toh:hwdata:hootoo:hootoo_tripmatenano_v15" data-wiki-id="toh:hwdata:hootoo:hootoo_tripmatenano_v15">Hoo Too HT-TM02</a>.
</p>
<div class="table sectionedit15"><table class="inline">
	<tr class="row0">
		<th class="col0"> Layer0 </th><td class="col1 centeralign" colspan="6">  raw flash, 8192 KiB  </td>
	</tr>
	<tr class="row1">
		<th class="col0"> Layer1 </th><td class="col1 centeralign" rowspan="3">  <strong>mtd0</strong> <br/>
<code>u-boot</code> <br/>
192 KiB  </td><td class="col2 centeralign" rowspan="3">  <strong>mtd1</strong> <br/>
<code>u-boot-env</code> <br/>
64 KiB  </td><td class="col3 centeralign" rowspan="3">  <strong>mtd2</strong> <br/>
<code>factory</code> <br/>
64 KiB  </td><td class="col4 centeralign" colspan="3">  <strong>mtd3</strong> <br/>
<code>firmware</code> <br/>
7872 KiB <sub><sup>(= FlashSize-(192+64+64))</sup></sub>  </td>
	</tr>
	<tr class="row2">
		<th class="col0"> Layer2 </th><td class="col1 centeralign" rowspan="2">  <strong>mtd4</strong> <br/>
<code>kernel</code> <br/>
about 1 MiB  </td><td class="col2 centeralign" colspan="2">  <strong>mtd5</strong> <br/>
<code>rootfs</code>  </td>
	</tr>
	<tr class="row3">
		<th class="col0"> Layer3 </th><td class="col1 centeralign">  <strong><code>/dev/root</code></strong> <br/>
around 2 MiB  </td><td class="col2 centeralign">  <strong>mtd6</strong> <br/>
<code>rootfs_data</code> <br/>
around 4.5 MiB  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table4&quot;,&quot;secid&quot;:15,&quot;range&quot;:&quot;16927-17416&quot;} -->
</div>

<h4 id="example_3d-link_dir-300">Example 3: D-Link DIR-300</h4>
<div class="level4">

<p>
For some devices, the OpenWrt partition <code>firmware</code> may not exist at all. The <a href="/toh/d-link/dir-300#flash_layout" class="wikilink1" title="toh:d-link:dir-300" data-wiki-id="toh:d-link:dir-300">DIR-300 flash layout</a> is such an example.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Explanations&quot;,&quot;hid&quot;:&quot;explanations&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:14,&quot;range&quot;:&quot;12796-17609&quot;} -->
<h2 class="sectionedit16" id="partitioning_of_nand_flash-based_devices">Partitioning of NAND flash-based devices</h2>
<div class="level2">

<p>
On these systems, the storage is presented by the kernel as an MTD device, and it is divided into MTD partitions. The device is not partitioned in the traditional way, where you store information about partitions in a <a href="https://en.wikipedia.org/wiki/GUID Partition Table" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/GUID Partition Table">GPT</a> or <a href="https://en.wikipedia.org/wiki/Master boot record" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Master boot record">MBR</a>. Instead, the partitioning information is directly known by the bootloader and the kernel, either through configuration, or more typically through baking it in at build time. For example, in the kernel it may simply be defined that <em>“MTD partition <strong><code>kernel</code></strong> starts at flash block <code>X</code> and consists of <code>Y</code> blocks”</em>. MTD partitions can be accessed by name or number.
</p>

<p>
Some NAND devices contain bootloaders that do not understand UBI partitions and thus cannot boot kernels contained in UBI volumes. The generic flash layout for these devices is:
</p>
<div class="table sectionedit17"><table class="inline">
	<tr class="row0">
		<th class="col0"> Layer0 </th><td class="col1 centeralign" colspan="7">  raw flash  </td>
	</tr>
	<tr class="row1">
		<th class="col0"> Layer1 </th><td class="col1 centeralign" rowspan="3">  bootloader <br/>
partition(s)  </td><td class="col2 centeralign" rowspan="3">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td><td class="col3 centeralign" rowspan="3">  Linux kernel <br/>
(raw image)  </td><td class="col4 centeralign" rowspan="3">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td><td class="col5 centeralign" colspan="2">  UBI partition  </td><td class="col7 centeralign" rowspan="3">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td>
	</tr>
	<tr class="row2">
		<th class="col0"> Layer2 </th><td class="col1 centeralign">  <strong><code>rootfs</code></strong> <br/>
mounted: “<code>/rom</code>”, <a href="/docs/techref/filesystems#squashfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">SquashFS</a> <br/>
size depends on selected packages  </td><td class="col2 centeralign">  <strong><code>rootfs_data</code></strong> <br/>
mounted: “<code>/overlay</code>”, <a href="/docs/techref/filesystems#ubifs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">UBIFS</a> <br/>
all remaining free space  </td>
	</tr>
	<tr class="row3">
		<th class="col0"> Layer3 </th><td class="col1 centeralign" colspan="2">  mounted: “<code>/</code>”, <a href="/docs/techref/filesystems#overlayfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">OverlayFS</a> <br/>
stacking <code>/overlay</code> on top of <code>/rom</code>  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table5&quot;,&quot;secid&quot;:17,&quot;range&quot;:&quot;18501-19194&quot;} -->
<p>
The generic flash layout for NAND devices that can boot kernels contained in UBI volumes is:
</p>
<div class="table sectionedit18"><table class="inline">
	<tr class="row0">
		<th class="col0"> Layer0 </th><td class="col1 centeralign" colspan="6">  raw flash  </td>
	</tr>
	<tr class="row1">
		<th class="col0"> Layer1 </th><td class="col1 centeralign" rowspan="3">  bootloader <br/>
partition(s)  </td><td class="col2 centeralign" rowspan="3">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td><td class="col3 centeralign" colspan="3">  UBI partition  </td><td class="col6 centeralign" rowspan="3">  optional <br/>
SoC <br/>
specific <br/>
partition(s)  </td>
	</tr>
	<tr class="row2">
		<th class="col0"> Layer2 </th><td class="col1 centeralign" rowspan="2">  <strong><code>kernel</code></strong> <br/>
Linux kernel <br/>
(raw image)  </td><td class="col2 centeralign">  <strong><code>rootfs</code></strong> <br/>
mounted: “<code>/rom</code>”, <a href="/docs/techref/filesystems#squashfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">SquashFS</a> <br/>
size depends on selected packages  </td><td class="col3 centeralign">  <strong><code>rootfs_data</code></strong> <br/>
mounted: “<code>/overlay</code>”, <a href="/docs/techref/filesystems#ubifs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">UBIFS</a> <br/>
all remaining free space  </td>
	</tr>
	<tr class="row3">
		<th class="col0"> Layer3 </th><td class="col1 centeralign" colspan="2">  mounted: “<code>/</code>”, <a href="/docs/techref/filesystems#overlayfs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">OverlayFS</a> <br/>
stacking <code>/overlay</code> on top of <code>/rom</code>  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table6&quot;,&quot;secid&quot;:18,&quot;range&quot;:&quot;19289-19940&quot;} -->
<p>
Many NAND devices share this scheme, but the flash layout can differ between the devices. Please see the wiki pages for each SoC and devices for information about a particular layout. In case the flash layout differs for your device please update the wiki pages.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Partitioning of NAND flash-based devices&quot;,&quot;hid&quot;:&quot;partitioning_of_nand_flash-based_devices&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:16,&quot;range&quot;:&quot;17610-20206&quot;} -->
<h3 class="sectionedit19" id="reserving_ubi_partition_space_for_user-defined_ubi_volumes">Reserving UBI partition space for user-defined UBI volumes</h3>
<div class="level3">

<p>
For <a href="/docs/techref/flash.layout#sysupgrade_and_rootfs_data" class="wikilink1" title="docs:techref:flash.layout" data-wiki-id="docs:techref:flash.layout">historical reasons</a> concerning NOR flash-based devices, sysupgrade works in an atypical fashion. During upgrades OpenWrt reads selected content from <strong><code>rootfs_data</code></strong> that it wants surviving the upgrade into RAM, creates an all-new <strong><code>rootfs_data</code></strong>, and writes back the selected content to it from RAM.
</p>

<p>
On NAND devices using UBI, sysupgrade partially reads the <strong><code>rootfs_data</code></strong> volume to RAM, deletes <strong><code>kernel</code></strong> (for kernel-in-UBI devices), <strong><code>rootfs</code></strong> and <strong><code>rootfs_data</code></strong> volumes, recreates <strong><code>kernel</code></strong> (if kernel-in-UBI) and <strong><code>rootfs</code></strong> volumes sizing them to fit the new images, recreates the <strong><code>rootfs_data</code></strong> volume utilizing all remaining free space in the UBI partition, flashes the firmware, and writes back data from RAM to <strong><code>rootfs_data</code></strong>.
</p>

<p>
While this setup worked well for old space-limited NOR devices, it may not be optimal for today&#039;s large NANDs. Nowadays, devices with flash sizes of 1 GiB or more are not uncommon, and for these devices moving all flash data to RAM and back is inefficient, unduly dangerous, and may not even be possible.
</p>

<p>
Fortunately the default behavior of sysupgrade on NAND devices using UBI can be modified: instead of recreating the <strong><code>rootfs_data</code></strong> volume utilizing all the free space in the UBI partition, sysupgrade can restrict the volume to a specific user-defined size. The requested <strong><code>rootfs_data</code></strong> size must be specified in bytes in the <strong><code>rootfs_data_max</code></strong> bootloader environment variable. (The variable is evaluated when read, so “128*1024*1024”, “0x8000000”, “134217728” are all valid and equivalent.)
</p>

<p>
The relevant bootloader variable can be read with this command:
</p>
<pre class="code">fw_printenv -n rootfs_data_max</pre>

<p>
Set with:
</p>
<pre class="code">fw_setenv rootfs_data_max &lt;VALUE&gt;</pre>

<p>
And cleared with:
</p>
<pre class="code">fw_setenv rootfs_data_max</pre>

<p>
Note that sysupgrade will fail if there is not enough space in the UBI partition to create <strong><code>rootfs_data</code></strong> of the specified size, and the contents of <strong><code>rootfs_data</code></strong> will then be lost. (The <strong><code>rootfs_data_max</code></strong> variable should have better been named <strong><code>rootfs_data_size</code></strong>.) The user must make sure that enough free space exists in UBI to accommodate growth of future OpenWrt images and/or custom OpenWrt images with more packages.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Reserving UBI partition space for user-defined UBI volumes&quot;,&quot;hid&quot;:&quot;reserving_ubi_partition_space_for_user-defined_ubi_volumes&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:19,&quot;range&quot;:&quot;20207-22613&quot;} -->
<h3 class="sectionedit20" id="examplecreating_a_ubi_volume_for_persistent_storage_across_sysupgrades">Example: Creating a UBI volume for persistent storage across sysupgrades</h3>
<div class="level3">

<p>
In an Askey RT4230W REV6 router with 512 MiB flash, the <strong><code>rootfs_data</code></strong> volume is normally sized at around 370 MiB (the remaining flash space being used for bootloaders, SoC-specific partitions, kernel, rootfs, and recovery). You can check this using:
</p>
<pre class="code">root@router:~# ubinfo -d 0 -N rootfs_data
Volume ID:   2 (on ubi0)
Type:        dynamic
Alignment:   1
Size:        3086 LEBs (391847936 bytes, 373.6 MiB)
State:       OK
Name:        rootfs_data
Character device major/minor: 246:3</pre>

<p>
Given that this volume is routinely wiped by sysupgrade, storing any remotely valuable files here would be ill-advised. For this router you might choose to limit <strong><code>rootfs_data</code></strong> to a generous 128 MiB, and create a new 192 MiB UBIFS volume for persistent storage, while still reserving 50+ MiB as free space to accommodate future growth of OpenWrt images. Let&#039;s do just that and name the new volume <strong><code>extra</code></strong>.
</p>

<p>
First you need to limit <strong><code>rootfs_data</code></strong> to 128 MiB for all following sysupgrades:
</p>
<pre class="code">root@router:~# fw_setenv rootfs_data_max 0x8000000</pre>

<p>
Next do a sysupgarde (even if no upgrade is needed) to resize <strong><code>rootfs_data</code></strong>. After that, verify its new size:
</p>
<pre class="code">root@router:~# ubinfo -d 0 -N rootfs_data
Volume ID:   2 (on ubi0)
Type:        dynamic
Alignment:   1
Size:        1058 LEBs (134340608 bytes, 128.1 MiB)
State:       OK
Name:        rootfs_data
Character device major/minor: 246:3</pre>

<p>
You just freed 240+ MiB in the UBI partition. Next, you could manually create, format, and mount a new UBIFS volume. But OpenWrt has a tool to automate this, so let&#039;s use it.
</p>

<p>
Connect the router to the internet if necessary, and use Luci to install package <code><strong>uvol</strong></code> (<strong>System &gt; Software</strong>). You might also want to install your favorite text editor now (<code><strong>nano-full</strong></code> is a good option).
</p>

<p>
Now check the installation (sizes are in bytes):
</p>
<pre class="code">root@router:~# uvol list
root@router:~# uvol total
422576128
root@router:~# uvol free
253317120</pre>

<p>
Create and enable the <code><strong>extra</strong></code> volume using <code><strong>uvol</strong></code>:
</p>
<pre class="code">root@router:~# uvol create extra $(( 192*1024*1024 )) rw
Volume ID 4, size 1586 LEBs (201383936 bytes, 192.0 MiB), LEB size 126976 bytes (124.0 KiB), dynamic, name &quot;uvol-wp-extra&quot;, alignment 1
root@router:~# uvol up extra
root@router:~# uvol list
extra rw 201383936
root@router:~# mount | grep extra
/dev/ubi0_4 on /tmp/run/uvol/extra type ubifs (rw,relatime,assert=read-only,ubi=0,vol=4)</pre>

<p>
You do not like the default mount path (<code><strong>/tmp/run/uvol/extra</strong></code>), so you change it to <code><strong>/extra</strong></code> using you text editor:
</p>
<pre class="code">root@router:~# nano /etc/config/fstab </pre>

<p>
Finally reboot and check that your new volume is mounted where you want it:
</p>
<pre class="code">root@router:~# mount | grep extra
/dev/ubi0_4 on /extra type ubifs (rw,relatime,assert=read-only,ubi=0,vol=4)</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Example: Creating a UBI volume for persistent storage across sysupgrades&quot;,&quot;hid&quot;:&quot;examplecreating_a_ubi_volume_for_persistent_storage_across_sysupgrades&quot;,&quot;codeblockOffset&quot;:4,&quot;secid&quot;:20,&quot;range&quot;:&quot;22614-25552&quot;} -->
<h2 class="sectionedit21" id="mtd_memory_technology_device_and_mtdsplit">MTD (Memory Technology Device) and MTDSPLIT</h2>
<div class="level2">

<p>
The Linux kernel treats “raw/host-managed” flash memory (NOR and NAND alike) as an MTD (Memory Technology Device). An MTD is different to a <a href="https://en.wikipedia.org/wiki/block device" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/block device">block device</a> or a <a href="https://en.wikipedia.org/wiki/character device" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/character device">character device</a>.
</p>

<p>
On a common block device such as a hard drive, the storage space is split up into “blocks”, which are also named “sectors”, of a size of 512 Bytes or 4096 Bytes. Blocks do not get corrupted during common operation, but only exceptionally. In the very rare case this happens, the LBA hard disk controller takes care, that accesses to such a bad block are redirected to a replacement block. Block devices support 2 main operations - read a whole block and write a whole block. When a block device is partitioned, the information is stored in the <a href="https://en.wikipedia.org/wiki/Master boot record" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Master boot record">MBR</a> or the <a href="https://en.wikipedia.org/wiki/GUID Partition Table" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/GUID Partition Table">GPT</a>.
</p>

<p>
Flash memory using MTD is different from this.
</p>

<p>
The storage space of a MTD is split up into “erase-blocks”, of a size of e.g 64 KiB, 128 KiB or much more, which themselves are split up into “blocks”, which are more correctly named “pages”, of smaller sizes.
</p>

<p>
A single “page” can be written to, but it cannot be overwritten, but instead the entire “erase block” that page is part of, has to be erased before it becomes possible to re-write its “pages”. Erase-blocks do become worn out after some number of erase cycles – typically 100K-1G for SLC NAND and NOR flashes, and 1K-10K for MLC NAND flashes. Erase-blocks may become bad (only NAND). In case of “FTL flash”, the controller should notice and avoid further access to bad erase-blocks. In case of “raw flash”, the operating system should deal with such cases.
</p>

<p>
MTD devices support 3 main operations - read from some offset within an erase block, write to some offset within an erase-block, and erase a whole erase-block.
</p>

<p>
The utility program <a href="/docs/techref/mtd" class="wikilink1" title="docs:techref:mtd" data-wiki-id="docs:techref:mtd">mtd</a> can be used to manage MTD devices.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;MTD (Memory Technology Device) and MTDSPLIT&quot;,&quot;hid&quot;:&quot;mtd_memory_technology_device_and_mtdsplit&quot;,&quot;codeblockOffset&quot;:11,&quot;secid&quot;:21,&quot;range&quot;:&quot;25553-27470&quot;} -->
<h3 class="sectionedit22" id="mtd_partitions">MTD partitions</h3>
<div class="level3">

<p>
The MTD device is often subdivided into logical chunks of memory called partitions. Each partition start at the beginning of an erase-block and end at the end of an erase-block.
</p>

<p>
The partitioning of MTD devices is not stored in some MBR/GPT, but it is done in the Linux Kernel using MTD-specific partition parsers determining the location and size of these partitions. (sometimes the partitioning is implemented independently in the <a href="/docs/techref/bootloader" class="wikilink1" title="docs:techref:bootloader" data-wiki-id="docs:techref:bootloader">bootloader</a> as well!).
</p>

<p>
The kernel boot process involves discovering of partitions within the NOR flash and it can be done by various target-dependent means:
</p>
<ul>
<li class="level1"><div class="li"> some bootloaders store a partition table at a known location</div>
</li>
<li class="level1"><div class="li"> some pass the partition layout via kernel command line</div>
</li>
<li class="level1"><div class="li"> some pass the partition layout using Device Tree</div>
</li>
<li class="level1"><div class="li"> some targets require specifying the kernel command line at the compile time (thus overriding the one provided by the bootloader).</div>
</li>
</ul>

<p>
Some of these schemes but not all are implemented in the mainline Linux kernel. The standard kernel can usually detect the top level coarse partitioning scheme, but not the more fine-grained sub-partitions.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;MTD partitions&quot;,&quot;hid&quot;:&quot;mtd_partitions&quot;,&quot;codeblockOffset&quot;:11,&quot;secid&quot;:22,&quot;range&quot;:&quot;27471-28623&quot;} -->
<h3 class="sectionedit23" id="mtdsplit">MTDSPLIT</h3>
<div class="level3">

<p>
In order to deal with some of the custom flash partitioning schemes directly in the kernel, OpenWrt has developed <code>mtdsplit</code> which is a set of patches currently maintained separately from the mainline kernel, but used in OpenWrt to parse different flash layouts and split them into further “logical” partitions.
</p>

<p>
This is done recursively so that further split of a new “child” partition may be attempted. Whether an attempt is made to split a partition depends on the partition name.
</p>
<ul>
<li class="level1"><div class="li"> <code>rootfs</code> is hardcoded to be split.</div>
</li>
<li class="level1"><div class="li"> <code>CONFIG_MTD_SPLIT_FIRMWARE</code> can be used to control whether attempt is made on <code>firmware</code> partition. The most common splitting here is kernel, followed by padding, followed by SquashFS root filesystem, followed by padding, followed by free space.</div>
</li>
</ul>

<p>
During splitting, the kernel walks the erase blocks and detects magic bytes via parsers. Each partition type (usually determined from name) has its own list of parsers.
</p>

<p>
New partitions are usually some offset into the start of the original partition. The size and number of the “children” depends on what is detected. For example if SquashFS image is found then the <code>rootfs</code> partition is added. For SquashFS image the splitter also automatically adds <code>rootfs_data</code> to the list of the available mtd partitions, setting this partition&#039;s beginning to the first appropriate address after the SquashFS end and size to the remainder of the <code>rootfs</code> partition.
</p>

<p>
The resulting list of split off partitions is stored in RAM only, so no partition table of any kind gets actually modified. This also includes detection and creation of <code>ubi</code> partition and others, as well as for vendor-specific layouts.
</p>

<p>
For more details please refer to the code for the mtdsplit:
<a href="https://github.com/openwrt/openwrt/tree/master/target/linux/generic/files/drivers/mtd/mtdsplit" class="urlextern" title="https://github.com/openwrt/openwrt/tree/master/target/linux/generic/files/drivers/mtd/mtdsplit" rel="ugc nofollow">https://github.com/openwrt/openwrt/tree/master/target/linux/generic/files/drivers/mtd/mtdsplit</a>
</p>

<p>
For overlaying a special <code>mini_fo</code> filesystem is used, the <code>README</code> is available from the sources at
<a href="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/209-mini_fo.patch" class="urlextern" title="https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/209-mini_fo.patch" rel="ugc nofollow">https://dev.openwrt.org/browser/trunk/target/linux/generic/patches-2.6.37/209-mini_fo.patch</a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;MTDSPLIT&quot;,&quot;hid&quot;:&quot;mtdsplit&quot;,&quot;codeblockOffset&quot;:11,&quot;secid&quot;:23,&quot;range&quot;:&quot;28624-30689&quot;} -->
<h2 class="sectionedit24" id="ubi_unsorted_block_images">UBI (Unsorted Block Images)</h2>
<div class="level2">

<p>
Unsorted Block Images (UBI) is an <code>erase block</code> management layer in the Linux kernel for raw NAND flash memory chips. It is layer on top of the MTD layer. UBI is used by <a href="/docs/techref/filesystems#ubifs" class="wikilink1" title="docs:techref:filesystems" data-wiki-id="docs:techref:filesystems">UBIFS</a>.
</p>

<p>
UBI serves two purposes, tracking “bad erase blocks” of a raw NAND flash memory chip and also providing wear-leveling. To accomplish this, UBI maps <em>logical erase blocks</em> to <em>physical erase blocks</em> and presents the first ones to higher layers.
</p>
<ul>
<li class="level1"><div class="li"> [<a href="http://www.linux-mtd.infradead.org/doc/ubi.html" class="urlextern" title="http://www.linux-mtd.infradead.org/doc/ubi.html" rel="ugc nofollow">http://www.linux-mtd.infradead.org/doc/ubi.html</a> UBI Documentation]</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;UBI (Unsorted Block Images)&quot;,&quot;hid&quot;:&quot;ubi_unsorted_block_images&quot;,&quot;codeblockOffset&quot;:11,&quot;secid&quot;:24,&quot;range&quot;:&quot;30690-31267&quot;} -->
<h2 class="sectionedit25" id="discovery_how_to_find_out">Discovery (How to find out)</h2>
<div class="level2">
<pre class="code">cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00020000 00010000 &quot;u-boot&quot;
mtd1: 00140000 00010000 &quot;kernel&quot;
mtd2: 00690000 00010000 &quot;rootfs&quot;
mtd3: 00530000 00010000 &quot;rootfs_data&quot;
mtd4: 00010000 00010000 &quot;art&quot;
mtd5: 007d0000 00010000 &quot;firmware&quot;</pre>

<p>
The <em>erasesize</em> is the <a href="https://en.wikipedia.org/wiki/Block (data storage)" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Block (data storage)">block size</a> of the flash, in this case 64KiB. The <em>size</em> is little or big <a href="https://en.wikipedia.org/wiki/Endianess" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Endianess">endian</a> hex value in Bytes. In case of little endian, you switch to hex-mode and enter 02 0000 into the calculator for example and convert to decimal (by switching back to decimal mode again). Then guess how they are nested into each other. Or execute <code>dmesg</code> after a fresh boot and look for something like:
</p>
<pre class="code">Creating 5 MTD partitions on &quot;spi0.0&quot;:
0x000000000000-0x000000020000 : &quot;u-boot&quot;
0x000000020000-0x000000160000 : &quot;kernel&quot;
0x000000160000-0x0000007f0000 : &quot;rootfs&quot;
mtd: partition &quot;rootfs&quot; set to be root filesystem
mtd: partition &quot;rootfs_data&quot; created automatically, ofs=2C0000, len=530000
0x0000002c0000-0x0000007f0000 : &quot;rootfs_data&quot;
0x0000007f0000-0x000000800000 : &quot;art&quot;
0x000000020000-0x0000007f0000 : &quot;firmware&quot;</pre>

<p>
These are the start and end offsets of the partitions as hex values in Bytes. Now you don&#039;t have to guess which is nested in which. E.g. 02 0000 = 131.072 Bytes = 128KiB.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Discovery (How to find out)&quot;,&quot;hid&quot;:&quot;discovery_how_to_find_out&quot;,&quot;codeblockOffset&quot;:11,&quot;secid&quot;:25,&quot;range&quot;:&quot;31268-32626&quot;} -->
<h2 class="sectionedit26" id="details">Details</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Details&quot;,&quot;hid&quot;:&quot;details&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:26,&quot;range&quot;:&quot;32627-32646&quot;} -->
<h3 class="sectionedit27" id="generic">generic</h3>
<div class="level3">

<p>
The flash chip can be represented as a large block of continuous space:
</p>
<div class="table sectionedit28"><table class="inline">
	<tr class="row0">
		<td class="col0 leftalign"> start of flash ................. end of flash  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table7&quot;,&quot;secid&quot;:28,&quot;range&quot;:&quot;32738-32788&quot;} -->
<p>
There is no ROM to boot from; at power up the CPU begins executing the code at the very start of the flash. Luckily this isn&#039;t the firmware or we&#039;d be in real danger every time we reflashed. Boot is actually handled by a section of code we tend to refer to as the <a href="/docs/techref/bootloader" class="wikilink1" title="docs:techref:bootloader" data-wiki-id="docs:techref:bootloader">bootloader</a> (the BIOS of your PC <em>is</em> a bootloader).
</p>
<div class="table sectionedit29"><table class="inline">
	<thead>
	<tr class="row0">
		<td class="col0"> </td><th class="col1"> Boot Loader Partition </th><th class="col2"> Firmware Partition </th><th class="col3" colspan="3"> <code>Special Configuration Data</code> </th>
	</tr>
	</thead>
	<tr class="row1">
		<th class="col0 leftalign"> Atheros  </th><td class="col1 centeralign">  <a href="/docs/techref/bootloader/uboot" class="wikilink1" title="docs:techref:bootloader:uboot" data-wiki-id="docs:techref:bootloader:uboot">U-Boot</a>   </td><td class="col2 centeralign">  firmware  </td><td class="col3 centeralign" colspan="3">  <code>ART</code>         </td>
	</tr>
	<tr class="row2">
		<th class="col0"> Broadcom </th><td class="col1 centeralign">  CFE      </td><td class="col2 centeralign">  firmware  </td><td class="col3 centeralign" colspan="3">  <code>NVRAM</code>       </td>
	</tr>
	<tr class="row3">
		<th class="col0 leftalign"> Atheros  </th><td class="col1 centeralign">  RedBoot  </td><td class="col2 centeralign">  firmware  </td><td class="col3 centeralign">  <code>FIS recovery</code>  </td><td class="col4 centeralign">  <code>RedBoot config</code>  </td><td class="col5 centeralign">  <code>boardconfig</code>  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table8&quot;,&quot;secid&quot;:29,&quot;range&quot;:&quot;33113-33450&quot;} -->
<p>
The partition or partitions containing so called <em>Special Configuration Data</em> differ very much from each other. Example: The <code>ART</code>-partition you will meet in conjunction with Atheros-Wireless and U-Boot, contains only data regarding the wireless driver, while the <code>NVRAM</code>-partition of broadcom devices is used for much more than only that. There are special utilities to access and modify special configuration partitions. For Broadcom devices this is the <code>nvram</code> utility. To find out what is written in <code>NVRAM</code> you can run <code>nvram show</code>.
</p>

<p>
Note that clearing these special configuration data partitions like <code>ART, NVRAM</code> and <code>FIS</code> does not clear much of OpenWrt&#039;s configuration, unlike other router software which keep configuration data solely in e.g. <code>NVRAM</code>. Instead, as a consequence of using the overlay_fs filesystem configuration with JFFS2 flash partition, the whole file system is writable and allows the flexibility of extending your OpenWrt installation in any way you want. OpenWrt&#039;s main configuration is therefore just kept in the root file system, using <a href="/docs/guide-user/base-system/uci" class="wikilink1" title="docs:guide-user:base-system:uci" data-wiki-id="docs:guide-user:base-system:uci">UCI</a> configuration files. For convenience, many other packages are made UCI compatible. If you want to reset your complete installation you should use OpenWrt&#039;s built-in functionality such as <a href="/docs/guide-user/installation/generic.sysupgrade" class="wikilink1" title="docs:guide-user:installation:generic.sysupgrade" data-wiki-id="docs:guide-user:installation:generic.sysupgrade">sysupgrade</a> to restore settings, by clearing the JFFS2 partition. Or, if you cannot boot normally, you can wipe or change the JFFS2 partition using OpenWrt&#039;s <a href="/docs/guide-user/troubleshooting/failsafe_and_factory_reset" class="wikilink1" title="docs:guide-user:troubleshooting:failsafe_and_factory_reset" data-wiki-id="docs:guide-user:troubleshooting:failsafe_and_factory_reset">failsafe mode</a> (look in your device&#039;s dedicated page for information how to boot into failsafe). 
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;generic&quot;,&quot;hid&quot;:&quot;generic&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:27,&quot;range&quot;:&quot;32647-35135&quot;} -->
<h3 class="sectionedit30" id="broadcom_with_cfe">broadcom with CFE</h3>
<div class="level3">

<p>
If you dig into the “firmware” section you&#039;ll find a trx. A trx is just an encapsulation, which looks something like this:
</p>
<div class="table sectionedit31"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0" colspan="7"> trx-header </th>
	</tr>
	</thead>
	<tr class="row1">
		<td class="col0 leftalign"> HDR0  </td><td class="col1 centeralign">  length  </td><td class="col2 centeralign">  crc32  </td><td class="col3 centeralign">  flags  </td><td class="col4 centeralign">  pointers  </td><td class="col5 centeralign">  data  </td><td class="col6"></td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table9&quot;,&quot;secid&quot;:31,&quot;range&quot;:&quot;35289-35372&quot;} -->
<p>
“HDR0” is a magic value to indicate a trx header, rest is 4 byte unsigned values followed by the actual contents. In short, it&#039;s a block of data with a length and a checksum. So, our flash usage actually looks something like this:
</p>
<div class="table sectionedit32"><table class="inline">
	<tr class="row0">
		<td class="col0 centeralign">  CFE  </td><td class="col1 centeralign">  trx containing firmware  </td><td class="col2 centeralign">  NVRAM  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table10&quot;,&quot;secid&quot;:32,&quot;range&quot;:&quot;35606-35653&quot;} -->
<p>
Except that the firmware is generally pretty small and doesn&#039;t use the entire space between CFE and NVRAM:
</p>
<div class="table sectionedit33"><table class="inline">
	<tr class="row0">
		<td class="col0 centeralign">  CFE  </td><td class="col1 centeralign">  trx firmware  </td><td class="col2 centeralign">  unused  </td><td class="col3 centeralign">  NVRAM  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table11&quot;,&quot;secid&quot;:33,&quot;range&quot;:&quot;35762-35809&quot;} -->
<p>
(<strong><em><code>NOTE</code></em>:</strong> The &lt;model&gt;.bin files are nothing more than the generic *.trx file with an additional header appended to the start to identify the model. The model information gets verified by the vendor&#039;s upgrade utilities and only the remaining data -- the trx -- gets written to the flash. When upgrading from within OpenWrt remember to use the *.trx file.)
</p>

<p>
So what exactly is the firmware?
</p>

<p>
The boot loader really has no concept of filesystems, it pretty much assumes that the start of the trx data section is executable code. So, at the very start of our firmware is the kernel. But just putting a kernel directly onto flash is quite boring and consumes a lot of space, so we compress the kernel with a heavy compression known as <a href="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Lempel–Ziv–Markov chain algorithm">LZMA</a>. Now the start of firmware is code for an LZMA decompress:
</p>
<div class="table sectionedit34"><table class="inline">
	<tr class="row0">
		<td class="col0 centeralign">  lzma decompress  </td><td class="col1 centeralign">  lzma compressed kernel  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table12&quot;,&quot;secid&quot;:34,&quot;range&quot;:&quot;36661-36709&quot;} -->
<p>
Now, the boot loader boots into an LZMA program which decompresses the kernel into RAM and executes it. It adds one second to the bootup time, but it saves a large chunk of flash space. (And if that wasn&#039;t amusing enough, it turns out the boot loader does know gzip compression, so we gzip compressed the LZMA decompression program)
</p>

<p>
Immediately following the kernel is the filesystem. We use SquashFS for this because it&#039;s a highly compressed readonly filesystem -- remember that altering the contents of the trx in any way would invalidate the crc, so we put our writable data in a JFFS2 partition, which is outside the trx. This means that our firmware looks like this:
</p>
<div class="table sectionedit35"><table class="inline">
	<tr class="row0">
		<td class="col0 centeralign">  trx  </td><td class="col1 leftalign"> gzip&#039;d lzma decompress  </td><td class="col2 centeralign">  lzma&#039;d kernel  </td><td class="col3 centeralign">  (SquashFS filesystem)  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table13&quot;,&quot;secid&quot;:35,&quot;range&quot;:&quot;37385-37464&quot;} -->
<p>
And the entire flash usage looks like this -
</p>
<div class="table sectionedit36"><table class="inline">
	<tr class="row0">
		<td class="col0 centeralign">  CFE  </td><td class="col1 centeralign">  trx  </td><td class="col2 centeralign">  gz&#039;d lzma  </td><td class="col3 centeralign">  lzma&#039;d kernel  </td><td class="col4 centeralign">  SquashFS  </td><td class="col5 centeralign">  JFFS2 filesystem  </td><td class="col6 centeralign">  NVRAM  </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table14&quot;,&quot;secid&quot;:36,&quot;range&quot;:&quot;37511-37604&quot;} -->
<p>
That&#039;s about as tight as we can possibly pack things into flash.
</p>
<hr />

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;broadcom with CFE&quot;,&quot;hid&quot;:&quot;broadcom_with_cfe&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:30,&quot;range&quot;:&quot;35136-37676&quot;} -->
<h2 class="sectionedit37" id="explanations1">Explanations</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Explanations&quot;,&quot;hid&quot;:&quot;explanations1&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:37,&quot;range&quot;:&quot;37677-37701&quot;} -->
<h3 class="sectionedit38" id="what_is_an_image_file">What is an Image File?</h3>
<div class="level3">

<p>
An image file is byte by byte copy of data contained in a file system. If you installed a Debian or a Windows in the usual way onto one or two hard disk partitions and would afterwards copy the whole content byte by byte from the hard disk into one file:
</p>
<pre class="code bash"><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>sda <span class="re2">of</span>=<span class="sy0">/</span>media<span class="sy0">/</span>sdb3<span class="sy0">/</span>backup.dd</pre>

<p>
the obtained backup file <code>/media/sdb3/backup.dd</code>, could be used in the exact same manner like an OpenWrt-Image-File.
</p>

<p>
The difference is, that OpenWrt-Image-File are not created that way <img src="/lib/images/smileys/wink.svg" class="icon smiley" alt=";-)" /> They are being generated with the <a href="/docs/guide-user/additional-software/imagebuilder" class="wikilink1" title="docs:guide-user:additional-software:imagebuilder" data-wiki-id="docs:guide-user:additional-software:imagebuilder">Image Generator</a> (former called Image Builder). Other resources:
</p>
<ul>
<li class="level1"><div class="li"> <a href="/docs/techref/headers" class="wikilink1" title="docs:techref:headers" data-wiki-id="docs:techref:headers">headers</a></div>
</li>
<li class="level1"><div class="li"> back to <a href="/downloads" class="wikilink1" title="downloads" data-wiki-id="downloads">downloads</a></div>
</li>
<li class="level1"><div class="li"> About <a href="http://skaya.enix.org/wiki/FirmwareFormat" class="urlextern" title="http://skaya.enix.org/wiki/FirmwareFormat" rel="ugc nofollow">Broadcom Firmware Format</a></div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;What is an Image File?&quot;,&quot;hid&quot;:&quot;what_is_an_image_file&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:38,&quot;range&quot;:&quot;37702-&quot;} -->