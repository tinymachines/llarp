
<h1 class="sectionedit1" id="nftables">nftables</h1>
<div class="level1">
<!-- EDIT{&quot;target&quot;:&quot;plugin_wrap_start&quot;,&quot;hid&quot;:&quot;&quot;,&quot;secid&quot;:2,&quot;range&quot;:&quot;0-&quot;} --><div class="wrap_important plugin_wrap">
<p>
<strong>This advanced guide explains how nftables works under the hood, using a manual nftables configuration.</strong>
</p>

<p>
<strong>This guide is incompatible with fw4 since it is also generating nftables rules.</strong>
</p>

<p>
<strong>So, if you simply want to configure the firewall on your device, this is the wrong documentation!</strong>
</p>
</div><!-- EDIT{&quot;target&quot;:&quot;plugin_wrap_end&quot;,&quot;hid&quot;:&quot;&quot;,&quot;secid&quot;:3,&quot;range&quot;:&quot;0-&quot;} -->
<p>
<a href="https://netfilter.org/projects/nftables/" class="urlextern" title="https://netfilter.org/projects/nftables/" rel="ugc nofollow">nftables project</a> is an enhancement
to netfilter, re-using most of the existing code but enhancing/streamlining
based on experience.
</p>

<p>
As with
<a href="/docs/guide-user/firewall/netfilter_iptables/netfilter_openwrt" class="wikilink1" title="docs:guide-user:firewall:netfilter_iptables:netfilter_openwrt" data-wiki-id="docs:guide-user:firewall:netfilter_iptables:netfilter_openwrt">iptables</a>,
there is a large amount of information and examples available on the web
for <code>nftables</code>.  Some links include:
</p>
<ul>
<li class="level1"><div class="li"> <a href="https://netfilter.org/projects/nftables/" class="urlextern" title="https://netfilter.org/projects/nftables/" rel="ugc nofollow">nftables project</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://lwn.net/Articles/324251/" class="urlextern" title="https://lwn.net/Articles/324251/" rel="ugc nofollow">nftables Announcement</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://linuxnewbieguide.org/hello-nftables-goodbye-iptables" class="urlextern" title="https://linuxnewbieguide.org/hello-nftables-goodbye-iptables" rel="ugc nofollow">nftables reason</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://www.netfilter.org/projects/nftables/manpage.html" class="urlextern" title="https://www.netfilter.org/projects/nftables/manpage.html" rel="ugc nofollow">nft man page</a></div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;nftables&quot;,&quot;hid&quot;:&quot;nftables&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-1013&quot;} -->
<h2 class="sectionedit4" id="nftables_in_openwrt_2203_and_later">nftables in OpenWrt (22.03 and later)</h2>
<div class="level2">

<p>
Since OpenWrt 22.03, <a href="/docs/guide-user/firewall/overview" class="wikilink1" title="docs:guide-user:firewall:overview" data-wiki-id="docs:guide-user:firewall:overview">fw4</a> is used by default, and it generates nftables rules.
</p>

<p>
See <a href="/docs/guide-user/firewall/firewall_configuration" class="wikilink1" title="docs:guide-user:firewall:firewall_configuration" data-wiki-id="docs:guide-user:firewall:firewall_configuration">firewall configuration</a> to configure firewall rules with UCI and <a href="/docs/guide-user/firewall/netfilter_iptables/netfilter_management" class="wikilink1" title="docs:guide-user:firewall:netfilter_iptables:netfilter_management" data-wiki-id="docs:guide-user:firewall:netfilter_iptables:netfilter_management">netfilter management</a> to explore the nftables rules created by fw4.
</p>

<p>
In any case, the guide below will probably not work, because the manual rules will clash with rules generated by fw4.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;nftables in OpenWrt (22.03 and later)&quot;,&quot;hid&quot;:&quot;nftables_in_openwrt_2203_and_later&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:4,&quot;range&quot;:&quot;1014-1557&quot;} -->
<h2 class="sectionedit5" id="nftables_in_openwrt_2102_and_earlier">nftables in OpenWrt (21.02 and earlier)</h2>
<div class="level2">

<p>
Historically in OpenWrt (in 21.02 and before), nftables was not the primary form of firewall and <abbr title="Network Address Translation">NAT</abbr> in OpenWrt, that role was taken by iptables - and that was what is set via the web interface in OpenWrt. However if users are comfortable using the command line interface, nftables are supported by OpenWrt 21.02 and earlier. The rest of this article describes how to use them, users should do this with care, and read the general documentation for nftables.
</p>

<p>
Firstly nftables kernel modules, are in part not compatible with iptables, in particular the kernel module <code>iptable_nat</code> the nftables equivalents <code>nf_nat*</code> and <code>nf_masq</code>; so before using nftables you have to switch off the loading of iptable <abbr title="Network Address Translation">NAT</abbr>. This is easily done by:
</p>
<ul>
<li class="level1"><div class="li"> rm /etc/modules.d/ipt-nat</div>
</li>
</ul>

<p>
Which means that
</p>
<ul>
<li class="level1"><div class="li"> ipt_MASQUERADE</div>
</li>
<li class="level1"><div class="li"> iptable_nat</div>
</li>
<li class="level1"><div class="li"> xt_REDIRECT</div>
</li>
<li class="level1"><div class="li"> xt_nat</div>
</li>
</ul>

<p>
are not loaded.
</p>

<p>
The nf kernel modules are already loaded via:
</p>
<ul>
<li class="level1"><div class="li"> /etc/modules.d/nf*</div>
</li>
</ul>

<p>
For nftables though need additional kernel modules, and user space executables and libraries:
</p>

<p>
Kernel:
</p>
<ul>
<li class="level1"><div class="li"> kmod-nft-core</div>
</li>
<li class="level1"><div class="li"> kmod-nft-nat</div>
</li>
<li class="level1"><div class="li"> kmod-nfnetlink</div>
</li>
</ul>

<p>
Executable:
</p>
<ul>
<li class="level1"><div class="li"> nftables</div>
</li>
</ul>

<p>
And Library:
</p>
<ul>
<li class="level1"><div class="li"> libnftnl</div>
</li>
<li class="level1"><div class="li"> libmnl</div>
</li>
</ul>

<p>
Most of these can all be installed at at the same time via
</p>
<ul>
<li class="level1"><div class="li"> opkg update</div>
</li>
<li class="level1"><div class="li"> opkg install nftables</div>
</li>
</ul>

<p>
Which pulls in the needed libraries, kernel modules and executables.
</p>

<p>
Not all the kernel modules are loaded, so for example if you wish to do <abbr title="Network Address Translation">NAT</abbr> you will also need:
</p>
<ul>
<li class="level1"><div class="li"> opkg install kmod-nft-nat</div>
</li>
</ul>

<p>
And possibly more, depending on your needs.
</p>

<p>
nftables can be configured via the command line, just like iptables, all be it with a different syntax. However nftables can also read a “c” like script - and this script is far more readable, and the suggested way to use nftables. This needs to be saved in a file, and the suggested location is /etc/nftables.conf. An example script is given at the bottom of this page, and worth studying. The rest of this page uses this script as an example. In this example there are 4 different ip inputs:
</p>
<ul>
<li class="level1"><div class="li"> <strong>lo</strong> - for internal packets</div>
</li>
<li class="level1"><div class="li"> <strong>br-lan</strong> - for the ethernet, four different ports, but joined in a switch</div>
</li>
<li class="level1"><div class="li"> <strong>wlan0</strong> - the WiFi connection</div>
</li>
<li class="level1"><div class="li"> <strong>pppoa-wan</strong> - the <abbr title="Wide Area Network">WAN</abbr> connection, across ADSL</div>
</li>
</ul>

<p>
The aim here is to join together the first three, so they can communicate. To set up firewall towards the <abbr title="Wide Area Network">WAN</abbr>. To set up <abbr title="Network Address Translation">NAT</abbr> for ipv4. And to let in a few ports on the <abbr title="Wide Area Network">WAN</abbr>.	
</p>
<pre class="code">table ip nat {
	chain prerouting {
		type nat hook prerouting priority 0; policy accept;
	}

	chain postrouting {
		type nat hook postrouting priority 100; policy accept;
	}
}</pre>

<p>
This introduces several concepts. The script is made up of tables, that contain chains, that contain rules. In iptables tables also exist, but in only certain types. nftables is more flexible, in that the tables can be called anything. Convention is though to use the iptables names by default. So in this case the table is called “nat” as it contains <abbr title="Network Address Translation">NAT</abbr> rules, the <abbr title="Network Address Translation">NAT</abbr> nature though is only set up in the chains with the <code>type nat</code>. The table contains two chains, one for “prerouting” and one for “postrouting” again these are just names, their behaviour is only set up with the “hook {pre|post}routing”. The last point is this acts on the family “ip”, there are only six families in nftables:
</p>
<ul>
<li class="level1"><div class="li"> <strong>ip</strong> - ipv4 packets</div>
</li>
<li class="level1"><div class="li"> <strong>ip6</strong> - ipv6 packets</div>
</li>
<li class="level1"><div class="li"> <strong>inet</strong> - both ipv4 and ipv6 packets</div>
</li>
<li class="level1"><div class="li"> <strong>arp</strong> - arp packets</div>
</li>
<li class="level1"><div class="li"> <strong>bridge</strong> - bridge rules</div>
</li>
<li class="level1"><div class="li"> <strong>netdev</strong> - for netdev and ingress</div>
</li>
</ul>

<p>
This is similar to iptables family of commands, but under nftables there are all under the same command. Also nftables contains the concept <code>inet</code> that applies to all <abbr title="Internet Protocol">IP</abbr> packets, which means one set of rules can cover both. The one exception to <code>inet</code> packets in in <abbr title="Network Address Translation">NAT</abbr> tables (like this) where ip and ipv6 need to be separate.
</p>
<pre class="code">table ip nat {
	chain prerouting {
		type nat hook prerouting priority 0; policy accept;
		tcp dport 12345 dnat to 192.168.2.111:ssh
	}
}</pre>

<p>
This is the rule, it says router when a packet arrives for tcp port 12345, that it is forward only the ssh port on a machine on the <abbr title="Local Area Network">LAN</abbr>. This is forwarded using <code>dnat</code> - destination <abbr title="Network Address Translation">NAT</abbr>, as its a ssh connection, and anything back from the machine on <abbr title="Local Area Network">LAN</abbr> is send back to machine sending the original packet. This is done in <code>prerouting</code> it is done as soon as the packet enters the machine. A similar command would used if you wanted a WWW server on a local machine exported to the <abbr title="Wide Area Network">WAN</abbr> so people could connect over the internet.
</p>
<pre class="code">table ip nat {
	chain postrouting {
		type nat hook postrouting priority 100; policy accept;
		oiftype ppp masquerade
	}
}</pre>

<p>
This is another <abbr title="Network Address Translation">NAT</abbr>, its the main <abbr title="Network Address Translation">NAT</abbr> so that <abbr title="Local Area Network">LAN</abbr> can get out to the internet on the <abbr title="Wide Area Network">WAN</abbr>, but looking like the <abbr title="Wide Area Network">WAN</abbr> connection. <code>masquerade</code> is a type of snat - Source <abbr title="Network Address Translation">NAT</abbr>. On packets it changes the source address, in a snat the address can be set, but on a <code>masquerade</code> the address is always set to the port it is going out on. In this case the port is set by <code>oiftype ppp</code>, this means the <abbr title="Wide Area Network">WAN</abbr>, but the reason isn&#039;t easy to see. The <abbr title="Wide Area Network">WAN</abbr> is on an ADSL connection, this is a serial connection, which packets are sent across by using <code>ppp</code>. Now the <code>oiftype ppp</code> says only run this command on the output port if it is running ppp. However how are you to know this - you won&#039;t find this command described almost everywhere on the www. The simple way to learn about it though, is the command <code>nft describe oiftype</code>, and that shows what types of port nftable can detect, and includes <code>ppp</code>. This part of the code could also be written <code>oifname “pppoa-wan” masquerade</code> however testing for <code>ppp</code> is the simpler difference between the <abbr title="Wide Area Network">WAN</abbr> and <abbr title="Local Area Network">LAN</abbr> ports. Note you can see which <code>type</code> ports are under using the <code>ip a</code> command.
</p>
<pre class="code">table inet filter {
	chain input {
		type filter hook input priority 0; policy drop;
	}

	chain forward {
		type filter hook forward priority 0; policy drop;
	}

	chain output {
		type filter hook output priority 0; policy accept;
	}
}</pre>

<p>
This is the main filter table, it is set up in the same way as the nat table. The chain names (and table name) can be anything, but they only become tied to what they do on the <code>type</code> line which sets up their description.
</p>

<p>
The rules for <code>input</code> and <code>forward</code> are exactly the same, this is saying we treat packets from the <abbr title="Local Area Network">LAN</abbr> as the same for going on to the internet, as going to the router. Also in reverse, anything from the <abbr title="Wide Area Network">WAN</abbr> needs to pass either through the input or forward chain, so we treat both the same. The code is:
</p>
<pre class="code">		ct state { related, established } accept
		ct state invalid drop  
		iiftype != ppp accept
		tcp dport ssh accept
		ip protocol icmp accept     
		ip6 nexthdr ipv6-icmp accept
		iiftype ppp drop</pre>

<p>
The first <code>ct state</code> says that any packet we get back, that is related to something we sent, that it should be accepted. So when you ask for something from the <abbr title="Wide Area Network">WAN</abbr>, you get to see the reply. There is an important concept here, the test is on two different states <code>related</code> and <code>established</code>, if the ct state is either then the packet is accepted.  Writing a rule that matches multiple things at once is not possible in iptables, and this is one way nftables is simpler. The second <code>ct state</code> just drops bad packets. the <code>iiftype != ppp accept</code> and we see <code>iiftype</code> again - it this says that any packet that comes from somewhere that isn&#039;t a ppp port (e.g. the <abbr title="Wide Area Network">WAN</abbr>) then we should accept this. This allows everything from the <abbr title="Local Area Network">LAN</abbr> to propagate.
</p>

<p>
Next <code>tcp dport ssh accept</code> says accept all ssh connections, even from the <abbr title="Wide Area Network">WAN</abbr>. This is needed as the dnat is forwarding ssh connections across the router. Note though you probably don&#039;t want this on the input, as it means you allow the <abbr title="Wide Area Network">WAN</abbr> to log onto the router via ssh. This will quickly be picked up by port scans, and you find attacks on this port, so the ssh port (22) is best not enabled on the <abbr title="Wide Area Network">WAN</abbr> direction.
</p>

<p>
The <code>ip protocol icmp accept</code> says we take icmp packets from anywhere, these are mainly used for testing the internet, so do things like <code>ping</code> packets - note this only works on <abbr title="Internet Protocol version 4">IPv4</abbr> packets. During testing you probably want this, but do you want <code>ping</code> responded to on the <abbr title="Wide Area Network">WAN</abbr>. The <code>ip6 nexthdr ipv6-icmp accept</code> does exactly the same on <abbr title="Internet Protocol version 6">IPv6</abbr> packets, this is needed for things like <code>Neighbour Discovery Protocol</code> - needed for stateless addresses to be set. However an important point with these two command, although the <code>table</code> acts on <code>inet</code> and this means both <abbr title="Internet Protocol version 4">IPv4</abbr> and <abbr title="Internet Protocol version 6">IPv6</abbr>, internal roles can be set to work on one or the other.
</p>

<p>
And finally the <code>iiftype ppp drop</code> just says that anything from the <abbr title="Wide Area Network">WAN</abbr>, that we haven&#039;t yet accepted, we should drop. So its setting up the firewall. Note that with the icmp packets, that if we wanted to drop these on the <abbr title="Wide Area Network">WAN</abbr>, we could just remove the icmp tests - as on the <abbr title="Local Area Network">LAN</abbr> all packets have already been accepted.
</p>

<p>
So this gives the full script, saved in <code>/etc/nftables.conf</code> as:
</p>
<pre class="code">flush ruleset
table ip nat {
	chain prerouting {
		type nat hook prerouting priority 0; policy accept;
		tcp dport 12345 dnat to 192.168.2.111:ssh
	}

	chain postrouting {
		type nat hook postrouting priority 100; policy accept;
		oiftype ppp masquerade
	}
}
table inet filter {
	chain input {
		type filter hook input priority 0; policy drop;
		ct state { related, established } accept
		ct state invalid drop
		iiftype != ppp accept
		tcp dport ssh accept
		ip protocol icmp accept
		ip6 nexthdr ipv6-icmp accept
		iiftype ppp drop
	}

	chain forward {
		type filter hook forward priority 0; policy drop;
		ct state { related, established } accept
		ct state invalid drop  
		iiftype != ppp accept
		tcp dport ssh accept
		ip protocol icmp accept     
		ip6 nexthdr ipv6-icmp accept
		iiftype ppp drop
	}

	chain output {
		type filter hook output priority 0; policy accept;
	}
}</pre>

<p>
The <code>flush ruleset</code> should be explained, its not part of the rules loaded into the kernel, but its an instruction to the kernel to clear out all existing rules. This is needed, as otherwise when adding the rules they would add to whatever is already in the kernel; but we wish the rules loaded from the file to be complete. There is another advantage to doing <code>flush ruleset</code> in the file with the rules, <code>nft -f</code> does an atomic replacement of the rules, e.g. all packets are processed either by the prexisting rules, or by the new rules, there is never a time when the old rules have been removed, but the new rules are not in place. Hence this is the safe way of replacing rules. 
</p>

<p>
Finally how is this loaded into the kernel. The easiest way is to add a lines to <code>/etc/rc.local</code> - <code>nft -f /etc/nftables.conf</code>. This file is run at boot, if first ensures the rules are empty (good for if the script is run twice) and then loads the nft rules from the file just set up. You can check it has been loaded correctly using <code>nft list ruleset</code>, which will take configuration loaded into kernel and decompile it into the <code>c</code> style of code. 
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;nftables in OpenWrt (21.02 and earlier)&quot;,&quot;hid&quot;:&quot;nftables_in_openwrt_2102_and_earlier&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;1558-12608&quot;} -->
<h2 class="sectionedit6" id="reflections">Reflections</h2>
<div class="level2">

<p>
And so some reflections on using nftables, why use it over iptables. Well it some ways its a choice, of which there are many , e.g {uClibc|musl libc} or {busybox|toybox}, this is the same {iptables|nftables}. Both do similar things, and I&#039;ve used both professionally. For me, I prefer <code>nftables</code> and for me its the <code>c</code> like script that is used to set up the tables - I find this far more readable than the command line that you have to use in <code>iptables</code>. Now this doesn&#039;t say you should use <code>nftables</code>, but you have a choice between <code>iptables</code> and <code>nftables</code>.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Reflections&quot;,&quot;hid&quot;:&quot;reflections&quot;,&quot;codeblockOffset&quot;:6,&quot;secid&quot;:6,&quot;range&quot;:&quot;12609-&quot;} -->