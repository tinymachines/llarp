
<h1 class="sectionedit1" id="wireguard_extras">WireGuard extras</h1>
<div class="level1">

</div>
<!-- EDIT{&quot;target&quot;:&quot;plugin_include_start&quot;,&quot;name&quot;:&quot;meta:infobox:howto_links&quot;,&quot;hid&quot;:&quot;&quot;,&quot;secid&quot;:2,&quot;range&quot;:&quot;0-&quot;} --><div class="plugin_include_content plugin_include__meta:infobox:howto_links">
<div class="level1">
<!-- EDIT{&quot;target&quot;:&quot;plugin_wrap_start&quot;,&quot;hid&quot;:&quot;&quot;,&quot;secid&quot;:4,&quot;range&quot;:&quot;0-&quot;} --><div class="wrap_info plugin_wrap">
<p>
This article relies on the following:
</p>
<ul>
<li class="level1"><div class="li"> Accessing <a href="/docs/guide-quick-start/walkthrough_login" class="wikilink1" title="docs:guide-quick-start:walkthrough_login" data-wiki-id="docs:guide-quick-start:walkthrough_login">web interface</a> / <a href="/docs/guide-quick-start/sshadministration" class="wikilink1" title="docs:guide-quick-start:sshadministration" data-wiki-id="docs:guide-quick-start:sshadministration">command-line interface</a></div>
</li>
<li class="level1"><div class="li"> Managing <a href="/docs/guide-user/base-system/uci" class="wikilink1" title="docs:guide-user:base-system:uci" data-wiki-id="docs:guide-user:base-system:uci">configs</a> / <a href="/docs/guide-user/additional-software/managing_packages" class="wikilink1" title="docs:guide-user:additional-software:managing_packages" data-wiki-id="docs:guide-user:additional-software:managing_packages">packages</a> / <a href="/docs/guide-user/base-system/managing_services" class="wikilink1" title="docs:guide-user:base-system:managing_services" data-wiki-id="docs:guide-user:base-system:managing_services">services</a> / <a href="/docs/guide-user/base-system/log.essentials" class="wikilink1" title="docs:guide-user:base-system:log.essentials" data-wiki-id="docs:guide-user:base-system:log.essentials">logs</a></div>
</li>
</ul>
</div><!-- EDIT{&quot;target&quot;:&quot;plugin_wrap_end&quot;,&quot;hid&quot;:&quot;&quot;,&quot;secid&quot;:5,&quot;range&quot;:&quot;0-&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;plugin_include_end&quot;,&quot;name&quot;:&quot;meta:infobox:howto_links&quot;,&quot;hid&quot;:&quot;&quot;,&quot;secid&quot;:3,&quot;range&quot;:&quot;0-&quot;} --></div>
<div class="level1">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;WireGuard extras&quot;,&quot;hid&quot;:&quot;wireguard_extras&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-113&quot;} -->
<h2 class="sectionedit6" id="introduction">Introduction</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> This how-to describes the most common <a href="https://en.wikipedia.org/wiki/WireGuard" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/WireGuard">WireGuard</a> tuning scenarios adapted for OpenWrt.</div>
</li>
<li class="level1"><div class="li"> Follow <a href="/docs/guide-user/services/vpn/wireguard/server" class="wikilink1" title="docs:guide-user:services:vpn:wireguard:server" data-wiki-id="docs:guide-user:services:vpn:wireguard:server">WireGuard server</a> for server setup and <a href="/docs/guide-user/services/vpn/wireguard/client" class="wikilink1" title="docs:guide-user:services:vpn:wireguard:client" data-wiki-id="docs:guide-user:services:vpn:wireguard:client">WireGuard client</a> for client setup.</div>
</li>
<li class="level1"><div class="li"> Follow <a href="/docs/guide-user/network/tunneling_interface_protocols#protocol_wireguard_wireguard_vpn" class="wikilink1" title="docs:guide-user:network:tunneling_interface_protocols" data-wiki-id="docs:guide-user:network:tunneling_interface_protocols">WireGuard protocol</a> for server and client configuration.</div>
</li>
<li class="level1"><div class="li"> Follow <a href="/docs/guide-user/services/ddns/client" class="wikilink1" title="docs:guide-user:services:ddns:client" data-wiki-id="docs:guide-user:services:ddns:client">DDNS client</a> to use own server with dynamic <abbr title="Internet Protocol">IP</abbr> address.</div>
</li>
<li class="level1"><div class="li"> Follow <a href="/docs/guide-user/services/rng" class="wikilink1" title="docs:guide-user:services:rng" data-wiki-id="docs:guide-user:services:rng">Random generator</a> to overcome low entropy issues.</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Introduction&quot;,&quot;hid&quot;:&quot;introduction&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:6,&quot;range&quot;:&quot;114-788&quot;} -->
<h2 class="sectionedit7" id="extras">Extras</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Extras&quot;,&quot;hid&quot;:&quot;extras&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:7,&quot;range&quot;:&quot;789-807&quot;} -->
<h3 class="sectionedit8" id="references">References</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="https://www.wireguard.com/install/" class="urlextern" title="https://www.wireguard.com/install/" rel="ugc nofollow">WireGuard for mobile/desktop/server</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://www.wireguard.com/quickstart/" class="urlextern" title="https://www.wireguard.com/quickstart/" rel="ugc nofollow">WireGuard documentation</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://wiki.archlinux.org/index.php/WireGuard" class="urlextern" title="https://wiki.archlinux.org/index.php/WireGuard" rel="ugc nofollow">WireGuard configuration examples</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://protonvpn.com/support/openwrt-wireguard" class="urlextern" title="https://protonvpn.com/support/openwrt-wireguard" rel="ugc nofollow">Wireguard on Openwrt router setup (Protonvpn.com guide)</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://mullvad.net/en/help/running-wireguard-router" class="urlextern" title="https://mullvad.net/en/help/running-wireguard-router" rel="ugc nofollow">Wireguard on Openwrt router setup (Mullvad.net guide)</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://www.ivpn.net/setup/router/openwrt-wireguard/" class="urlextern" title="https://www.ivpn.net/setup/router/openwrt-wireguard/" rel="ugc nofollow">Wireguard on Openwrt router setup (Ivpn.net guide)</a></div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;References&quot;,&quot;hid&quot;:&quot;references&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:8,&quot;range&quot;:&quot;808-1404&quot;} -->
<h3 class="sectionedit9" id="web_interface">Web interface</h3>
<div class="level3">

<p>
If you want to manage <abbr title="Virtual Private Network">VPN</abbr> settings and view <abbr title="Virtual Private Network">VPN</abbr> status using web interface.
Install the necessary packages.
</p>
<pre class="code bash"><span class="co0"># Install packages</span>
opkg update
opkg <span class="kw2">install</span> luci-proto-wireguard qrencode
service rpcd restart</pre>
<ul>
<li class="level1"><div class="li"> Navigate to <strong>LuCI → Network → Interfaces</strong> to configure WireGuard.</div>
</li>
<li class="level1"><div class="li"> Navigate to <strong>LuCI → Status → WireGuard</strong> to view WireGuard status.</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Web interface&quot;,&quot;hid&quot;:&quot;web_interface&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:9,&quot;range&quot;:&quot;1405-1802&quot;} -->
<h3 class="sectionedit10" id="connection_probevpn_automation_failover_script">Connection probe / VPN automation failover script</h3>
<div class="level3">

<p>
No current <abbr title="Virtual Private Network">VPN</abbr> providers have a Luci app for OpenWrt that acts like their <abbr title="Operating System">OS</abbr>-specific desktop, laptop &amp; mobile <abbr title="Virtual Private Network">VPN</abbr> clients. Those apps can dynamically pull <abbr title="Virtual Private Network">VPN</abbr> server info, and connect on an as-needed basis, to the closest/fastest <abbr title="Virtual Private Network">VPN</abbr> server, or other preferences you have <a href="https://github.com/litepresence/NordVPN-Server-Switcher/blob/master/nordvpn.py" class="urlextern" title="https://github.com/litepresence/NordVPN-Server-Switcher/blob/master/nordvpn.py" rel="ugc nofollow">(example)</a>. When moving your <abbr title="Virtual Private Network">VPN</abbr> client connection from your individual devices to the router, you must initially make your own (wireguard) interface(s) on the router. ( ProtonVPN examples: <a href="https://protonvpn.com/support/openwrt-wireguard" class="urlextern" title="https://protonvpn.com/support/openwrt-wireguard" rel="ugc nofollow">see here</a>, and <a href="https://www.reddit.com/r/ProtonVPN/comments/zf5b79/were_testing_ipv6_on_our_servers_and_we_need_your/" class="urlextern" title="https://www.reddit.com/r/ProtonVPN/comments/zf5b79/were_testing_ipv6_on_our_servers_and_we_need_your/" rel="ugc nofollow">here</a> ). However, since individual <abbr title="Virtual Private Network">VPN</abbr> servers can go down for maintenance, or have other issues, and you would otherwise lose the oversight, redundancy and error-checking provided by using a direct client-based app, one way to improve the conditions at the router, is to have a boot script periodically checking your <abbr title="Virtual Private Network">VPN</abbr> profile for connectivity. If the check fails, it either addresses the basic wan connectivity, if that failed, or if that is ok, it tries bringing up each <abbr title="Virtual Private Network">VPN</abbr> profile, one at a time. If none of them are able to connect, it logs that information so you can take corrective action.
</p>

<p>
<strong>REQUIREMENTS and PREREQUISITES:</strong>
</p>
<ul>
<li class="level1 node"><div class="li"> This script requires the <strong>fping</strong> package.</div>
<ul>
<li class="level2"><div class="li"> Extended functions require <strong>bash</strong>, per cake-autorate install guide.</div>
</li>
<li class="level2"><div class="li"> Extended functions of CAKE-AUTORATE/SQM auto-management are disabled by default, requiring <a href="/docs/guide-user/network/traffic-shaping/sqm#installation" class="wikilink1" title="docs:guide-user:network:traffic-shaping:sqm" data-wiki-id="docs:guide-user:network:traffic-shaping:sqm">OpenWRT SQM guide (luci-app-sqm)</a> and <a href="https://github.com/lynxthecat/cake-autorate/blob/master/INSTALLATION.md" class="urlextern" title="https://github.com/lynxthecat/cake-autorate/blob/master/INSTALLATION.md" rel="ugc nofollow">cake-autorate</a>. Cake-Autorate provide automated adjustments for cell connection variability compensation-optimization, on top of SQM.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> This script is an upgraded version of the script <a href="/toh/netgear/lbr20#qmiwwan04g_lte_monitoring_script" class="wikilink1" title="toh:netgear:lbr20" data-wiki-id="toh:netgear:lbr20">here</a>. For devices that have a cell modem, particularly Quectel cellular devices that seem to have firmware stability issues, which are also the cheapest cell devices and widely used in consumer hardware. This script augments the stability of the overall router operation.</div>
</li>
<li class="level1"><div class="li"> <strong>Plain QMI</strong> is supported. Not tested on other methods of <abbr title="Wireless Wide Area Network">WWAN</abbr> device, e.g. MBIM or other. ModemManager auto-management&#039;s routines would interfere with this script, so you&#039;d have to change the script accordingly. Quectel devices seem to have hard-lock issues after a few minutes of uptime, if the <abbr title="Maximum Transmission Unit">MTU</abbr> (MBIM or ModemManager) is set, but plain QMI seems quite stable.</div>
</li>
<li class="level1"><div class="li"> <strong>SQM can significantly increase router CPU requirements</strong></div>
</li>
<li class="level1"><div class="li"> Make sure your <abbr title="Wireless Wide Area Network">WWAN</abbr> interface name (e.g. &#039;qmippp&#039;) and <abbr title="Wireless Wide Area Network">WWAN</abbr> device name (&#039;wwan0&#039;) is <strong>the same</strong> as the one in the script. Modify the script as necessary for WWANNAME &amp; WWANDEVICE variable settings.</div>
</li>
<li class="level1"><div class="li"> <strong><abbr title="Internet Protocol version 4">IPv4</abbr> and <abbr title="Internet Protocol version 6">IPv6</abbr>: fping is testing both</strong>, and will report failure if either fails. Therefore, <a href="https://www.reddit.com/r/ProtonVPN/comments/zf5b79/were_testing_ipv6_on_our_servers_and_we_need_your/" class="urlextern" title="https://www.reddit.com/r/ProtonVPN/comments/zf5b79/were_testing_ipv6_on_our_servers_and_we_need_your/" rel="ugc nofollow">your VPN must support IPv4 &amp; IPv6</a>, or you can modify the function in the script to only test what you have.</div>
</li>
<li class="level1 node"><div class="li"> <strong>Set-up 4 <abbr title="Virtual Private Network">VPN</abbr> interfaces</strong></div>
<ul>
<li class="level3"><div class="li"> Make sure each <abbr title="Virtual Private Network">VPN</abbr> works, by itself. Here is a set-up guide: <a href="https://protonvpn.com/support/openwrt-wireguard" class="urlextern" title="https://protonvpn.com/support/openwrt-wireguard" rel="ugc nofollow">Wireguard on OpenWrt guide</a>. <strong>Uncheck &#039;Bring up on boot&#039;</strong> for each <abbr title="Virtual Private Network">VPN</abbr> interface.</div>
</li>
<li class="level3"><div class="li"> Modify the variable declarations in the script to match those names.</div>
</li>
<li class="level3"><div class="li"> <strong><abbr title="Virtual Private Network">VPN</abbr>=“0”</strong> if you do not want <abbr title="Virtual Private Network">VPN</abbr> support with this script.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <strong>The boot wait time is set to 4 seconds for testing purposes from the shell.</strong> The script will run-once, then exit (not loop). Set BOOTWAIT to 45 or more, when you have manually run this script and it works. Execute &#039;/root/wan-watchdog.sh &amp;&#039; and it will run in the background, then you can exit the shell. If you&#039;ve modified the rc.local as described below, it will be called at next boot.</div>
</li>
</ul>

<p>
MISC:<br/>

</p>
<ul>
<li class="level1"><div class="li"> Some functions in wan-watchdog, are pulled from /lib/functions/network.sh.</div>
</li>
<li class="level1"><div class="li"> As with all scripts, when creating it at /root/wan-watchdog.sh, you must do a &#039;chmod +x /root/wan-watchdog.sh&#039; to make it executable.  </div>
</li>
</ul>
<pre class="code">#!/bin/sh

#wan-watchdog.sh v.20250720
# Changelog: Newest comments at the top #
# Slight logging changes for clarification, some syntax updates, and timing issues (waiting longer for qmippp to come up)
# VPN=0 handling improvement/fixes.
# Enabled SQM and cake to run on the plain WWAN device, e.g. wwan0, if VPN=0.
# Cleaned up: the use of /lib/functions/network.sh
# Cleaned up: the bootwait logic. Funciontionally, the previous version of the script works fine, but it makes more sense to do it this way.
# Fixed the cake-autorate logic. Cake-autorate responds variously &#039;not running&#039; or &#039;inactive&#039; when it is not running (why?? who knows?).
# Added/changed/updated: clearing SQM interfaces after changing/starting VPN
# Added: Exporting CURRENTVPN value to file for use by cake-autorate.sh.
# Changed: write CURRENTVPN for use by outside scripts to /tmp not /root. It doesn&#039;t need to be /root / persistent between restarts.
# Added: logfile as variable instead of explicitly 
# Improved: FPING function to test IPv4 and IPv6 both, and issue a failure if either one fails.

# Setup: Call this script from rc.local with &#039;/root/wan-watchdog.sh &amp;&#039;
# On cell-connected routers, what this is designed-for, your rc.local calls this script at startup:
#
# sleep 15
# service sysntpd restart # To make sure the time &amp; date is set correctly on the router before this script runs.
# /root/wan-watchdog.sh &amp;

log_file=&quot;/root/wan_watchdoglog.txt&quot;

echo -e &quot;\n&quot; # new blank line
	if [ -f ${log_file} ]
		then 
		echo &quot;Logfile check. Logfile ${log_file} exists, continuing...&quot;
	elif ! [ -f ${log_file} ]
		then
		echo &quot;Logfile ${log_file} does not exist... creating.&quot;
		echo &quot;Logfile created on $(date).&quot; &gt; $log_file
	fi

# Ordinary: start-on-boot and loop, checking the connection, etc: Requires a value of &#039;45&#039; (seconds) or more.
# Testing mode: Less than 45 will cause this script to run 1 time then exit, and if there is a total wwan failure, it will echo to the screen &#039;reboot&#039; but not actually reboot the router.
# The wait period gives your modem time to connect. Should be at least 45 seconds under ordinary circumstances.
BOOTWAIT=&quot;4&quot;
# Usually 45-360 seconds. Initial waiting period before testing. Must be 45 or more to loop in an ordinary run.
# ATTENTION: If this value is less than xx (seconds, set below), this script will not loop back, nor reboot your router on total failure.
# Instead, this script will run 1 time, check if the wan connection (WWAN) is up, and, if you have set VPN to 1, it will check that too.
# This is done in case you reboot your router manually with the script in test mode, the script does not automatically keep running or go into a boot-loop.
	if [ $BOOTWAIT -ge 45 ] ; then # Test BOOTWAIT value if less/more than 60 to determine test run or normal run mode.
		echo &quot;Watchdog script running in normal mode. $(date).&quot; | tee -a &quot;$log_file&quot;
		TESTMODE=&quot;0&quot;
	elif [ $BOOTWAIT -lt 45 ] ; then
		echo &quot;Bootwait less than 45 seconds. Running in test Mode. $(date)&quot; &gt;&gt; &quot;$log_file&quot;
		echo &quot;Watchdog script running in test-mode, run once and exit.&quot;
		echo &quot;Verbose responses to screen / not logged, and no reboot.&quot;
		TESTMODE=&quot;1&quot;
	fi


LOOPWAIT=&quot;10&quot; # How long to wait after a complete process of checking connectivity, to do it again.

DOYOULIKECAKE=&quot;0&quot; # Set to 1 to enable the cake-autorate
# To add Cake-Autorate on top of SQM, for variable-speed internet uplinks (cellular, typically):
# 1. You must have SQM installed (luci-app-sqm).
# 2. Cake-autorotate must be already set-up according to: https://github.com/lynxthecat/cake-autorate/blob/master/INSTALLATION.md
# 3. Initially you must manually start each VPN profile, one at a time, and go to the Network-&gt;SQM QoS menu, and &#039;Enable this SQM Instance&#039;, set the DL/UL, and Queue Discipline to Cake/Layer-of-cake 
# 4. Do that with all 4 VPN instances individually.
# 5. Do it also with the plain wwan0 interface/device. Shut off all VPN&#039;s then configure Cake/layer-of-cake using the Luci SQM menu on it.
#	SQM will remember the configurations for each device: VPN&#039;s and raw wwan0. When it is restarted in this script, during testing
#	mode you will see errors for all the OTHER devices that are not active. That is normal.
# 6. Note: There are also some lines that need to be modified in /root/cake-autorate/config.primary.sh Cake-Autorate config, as follows:
#   Add:
#    read -r CAKEWAN &lt; /tmp/currentvpn.txt
#   Change:
#    dl_if=&quot;ifb4${CAKEWAN}&quot; # This will show up in current versions of cake-autorate&#039;s config.primary.sh as &quot;dl_if=ifb-wan&quot; instead of dl_if=ifb4wan. They should be changed as specified here.
#    ul_if=&quot;${CAKEWAN}&quot;
# 6. After you manually get cake-autorate working, DISABLE the cake-autorate service from auto-start: 
#	Choose &#039;disabled&#039; (from System-&gt;Startup) for cake-autorate. Instead, this script will manually start cake-autorate at the appropriate stage.

# Put here, your wwan/cell connection interface name &amp; wwan device name:
WWANNAME=&quot;qmippp&quot; # The WWAN Interface Name: used e.g. for the quectel modem restart portion of the script and detecting whether the wwan is working.
WWANDEVICE=&quot;wwan0&quot; # The WWAN DEVICE: used for the cake/sqm portion of the script when VPN=0

# Define whether you want to use VPN&#039;s: 1 for yes 0 for no. You may, for whatever reason, not want to use VPN&#039;s on your router at some time, e.g. during testing.
# ATTENTION: Reminder when you set-up all your VPN profiles, to configure them to NOT &#039;Start on boot&#039;. Let this script start them instead.
VPN=&quot;1&quot;

# Put here the names of your VPN Interfaces (Luci-&gt;Network-&gt;Interfaces):
# ATTENTION: None of your VPN profiles (interfaces) should be set to &#039;Start at boot&#039;. UNCHECK that. And manually test each one to make sure they work.
VPN1=&quot;protonvpn&quot;
VPN2=&quot;protonvpn2&quot;
VPN3=&quot;protonvpn3&quot;
VPN4=&quot;protonvpn4&quot;

WAITFOR=&quot;3&quot;
# for debugging, when manually running. Sets the length of pause between actions taken in the script, to give you time to read onscreen msgs.
# 2-5 typically for debugging, 0-1 normally when not.

# include functions:
. /lib/functions/network.sh

# Below is the custom FPING function: (not from /lib/functions/network.sh, but made specifically for this script instead) 
check_fping() {
    # Run the fping command and check if it succeeds
#     if [ &quot;$(fping --alive --interval=400 --count=5 --fast-reachable=1 --addr -4 fakewebsite.fake)&quot; ] ; then
    if [ &quot;$(fping --alive --interval=400 --count=5 --fast-reachable=1 --addr -4 cloudflare.com dns.google msn.com)&quot; ] &amp;&amp; [ &quot;$(fping --alive --interval=400 --count=5 --fast-reachable=1 --addr -6 cloudflare.com dns.google msn.com)&quot; ] ; then
        return 0  # Return success
    else
        return 1  # Return failure
    fi
}

########################### start ####################### 
echo -e &quot;\n&quot; # new blank line
echo &quot;Waiting ${BOOTWAIT} seconds...&quot;
sleep $BOOTWAIT # The startup delay must be first, to ensure the time and date recorded in the log is correct.

if [[ &quot;$TESTMODE&quot; == &quot;1&quot; ]] ; then
	echo &quot;Wan-watchdog script startup in testing mode. Waiting ${BOOTWAIT} seconds before checking connectivity.&quot;
	echo &quot;BOOTWAIT set to: ${BOOTWAIT}&quot;
	echo &quot;WAITFOR pause length set to: ${WAITFOR}&quot;
	echo &quot;Run once and exit. No log, no loop, and no reboot if total wan failure.&quot;
	echo &quot;Increase the BOOTWAIT value for ordinary start-up.&quot;
elif [[ &quot;$TESTMODE&quot; == &quot;0&quot; ]] ; then
	echo &quot;Wan-Watchdog script started / Router booted on $(date)&quot;
fi


if [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; &amp;&amp; &quot;$VPN&quot; == &quot;1&quot; ]]
	then
	# The next line addresses the automatically-applied fq_codel on the WWAN interface. Since we will be running cake-autorate inside the VPN usually, this should be removed/set to noqueue 
	echo &quot;Cake-autorate selected ON. VPN turned ON. Therefore, removing default fq_codel from basic ${WWANDEVICE}/${WWANNAME} interface..&quot;
	tc qdisc replace dev ${WWANDEVICE} root noqueue
fi

echo -e &quot;\n&quot; # new blank line
echo &quot;Entering wan &amp; vpn testing:&quot;
network_flush_cache
network_find_wan NET_IF_NAME
network_find_wan6 NET6_IF_NAME
# ATTENTION: Look at the following output during testing, to determine if you correctly set WWANDEVICE &amp; WWANNAME, assuming you are connected in a basic way to your default internet connection when you test-run this 
echo &quot;WWANDEVICE device is set to ${WWANDEVICE}&quot;
echo &quot;WANNNAME interface is set to ${WWANNAME}&quot;
echo &quot;NET_IF_NAME reports as ${NET_IF_NAME}&quot; # if NIN is null, then the WAN is not connected (usually during testing where WWANNAME has been manually stopped).
echo &quot;NET6_IF_NAME reports as ${NET6_IF_NAME}&quot; # same as above
# Ordinarily either NIN or N6IN must match WWANNAME, if the router is connected to the internet when you test-run this script, and you have no VPN profiles active.
# If neither NET or NET6 IF match WWANNAME, stop this script and correct the value for $WWANNAME stored at the top.
echo &quot;Sleeping for ${WAITFOR} seconds...&quot;
sleep $WAITFOR
# Connection Status: 0 Not connected-connection attempt failure, exit and reboot.
# Connection Status: 1 Unknown State, try to take corrective action
# Connection Status: 2 WWAN interface connected, fping success
# Connection Status: 3 WWAN &amp; VPN connected, fping success
NEEDREBOOT=&quot;0&quot; # Initialize
RELOADCAKE=&quot;0&quot; # Initialize
CONNECTIONSTATUS=&quot;1&quot; # Initialize
ACTIVEVPN=&quot;none&quot; # Initialize the -active and tested- VPN profile, to &#039;none&#039;.
sleep $WAITFOR

while [[ $CONNECTIONSTATUS -ge 1 ]]
do # While CONNECTION STATUS is 1 or greater, do the following loop:
	echo &quot;Pinging a variety of well-known ipv4 and ipv6 addresses...&quot;
	echo &quot;1 success on ipv4 and 1 success on ipv6, is enough. All of them failing, multiple times, will cause corrective actions.&quot;
	# if1
	if check_fping ; then
		echo &quot;Successful fping response. Further probing options - is VPN selected ON/OFF? Cake? Is VPN currently connected? etc&quot;
		echo -e &quot;\n&quot; # new blank line
		# if2
		if [[ &quot;$VPN&quot; -eq &quot;1&quot; ]] ; then # If VPN selector is turned ON, try/test VPN connections 1 through 4.
			echo &quot;VPN Option selector turned-on &#039;1&#039;. Getting current interface connection values...&quot;
			network_flush_cache
			network_find_wan NET_IF_NAME
			network_find_wan NET6_IF_NAME
			echo &quot;Current values for:&quot;
			echo &quot;NET_IF_NAME: ${NET_IF_NAME}&quot;
			echo &quot;NET6_IF_NAME: ${NET6_IF_NAME}&quot;
			echo &quot;WWANNAME interface: ${WWANNAME}&quot;
			echo &quot;WWANDEVICE device: ${WWANDEVICE}&quot;
			echo &quot;Checking if any VPN connections are currently up...&quot;
			sleep $WAITFOR
			# if3
			if [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN1&quot; ]] || [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN2&quot; ]] || [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN3&quot; ]] || [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN4&quot; ]]; then
				echo &quot;ACTIVEVPN is ${NET_IF_NAME}, is reported as up, and fping is successful!&quot;
				echo &quot;Basic WWAN Connection is up, and 1 out of 4 possible VPN profiles/interfaces are connected.&quot;
				echo &quot;Setting value of ACTIVEVPN to ${NET_IF_NAME}..&quot;
				ACTIVEVPN=$NET_IF_NAME
				echo &quot;Setting CONNECTIONSTATUS to 3..&quot;
				CONNECTIONSTATUS=&quot;3&quot;
				sleep $WAITFOR
				# if4
				if [[ -f /tmp/currentvpn.txt ]] ; then 
					echo &quot;/tmp/currentvpn.txt exists reading value into PREVIOUSVPN..&quot;
					read -r PREVIOUSVPN &lt; /tmp/currentvpn.txt
				else
					echo &quot;/tmp/currentvpn.txt does not exist. Initializing PREVIOUSVPN to &#039;none&#039;.&quot;
					PREVIOUSVPN=&quot;none&quot;
				fi # fi4
				echo &quot;Comparing ACTIVEVPN to PREVIOUSVPN:&quot;
				echo &quot;PREVIOUSVPN is: ${PREVIOUSVPN}..&quot;
				# if5
				if [[ &quot;$ACTIVEVPN&quot; == &quot;$PREVIOUSVPN&quot; ]] ; then
					# If ACTIVEVPN matches PREVIOUSVPN in this loop or run, then do nothing and continue
					echo &quot;Current VPN is the same as the previously-connected VPN profile, continuing...&quot;
					VPNCHANGED=&quot;0&quot;
					sleep $WAITFOR
				else # if the values do not match, then maybe the VPN has changed from previous, write the currentvpn to &#039;currentvpn.txt&#039;
					echo &quot;VPN has changed. Previous VPN was ${PREVIOUSVPN}. Current VPN is ${CURRENTVPN}&quot; | tee -a &quot;$log_file&quot;
					echo &quot;Writing changes to currentvpn.txt...&quot;
					VPNCHANGED=&quot;1&quot;
					echo &quot;$ACTIVEVPN&quot; &gt; /tmp/currentvpn.txt # write the current vpn value to a file, e.g. to be used by the cake autorate script.
					sleep $WAITFOR
				fi # fi5 Finished sensing and reacting to a match or mismatch between ACTIVEVPN and PREVIOUSVPN
			# if3 elif
			elif [[ &quot;$WWANNAME&quot; == &quot;$NET_IF_NAME&quot; || &quot;$NET6_IF_NAME&quot; ]] ; then # When WWAN interface is up, &amp; VPN selector is turned-on, but no VPN is up yet.
				echo &quot;VPN not up yet; WWAN network interface is up. Trying to get a VPN connection up...&quot; | tee -a &quot;$log_file&quot;
				sleep $WAITFOR
				echo &quot;Trying $VPN1...&quot;
				echo &quot;ifup ${VPN1}&quot;
				ifup $VPN1
				sleep 7 # wait for it to connect
				network_flush_cache
				network_find_wan NET_IF_NAME
				if [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN1&quot; ]] &amp;&amp; check_fping ; then
					ACTIVEVPN=$VPN1
					CONNECTIONSTATUS=&quot;3&quot;
					echo &quot;${VPN1} is up, and fping success!&quot;
				else
					echo &quot;Unable to connect to ${VPN1}... trying ${VPN2} profile...&quot; | tee -a &quot;$log_file&quot;
					echo &quot;ifdown ${VPN1}&quot;
					ifdown $VPN1
					sleep $WAITFOR
					echo &quot;ifup ${VPN2}&quot;
					ifup $VPN2
					sleep 7
					network_flush_cache
					network_find_wan NET_IF_NAME
					if [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN2&quot; ]] &amp;&amp; check_fping ; then
						ACTIVEVPN=$VPN2
						CONNECTIONSTATUS=&quot;3&quot;
						echo &quot;${VPN2} is up and fping success!&quot;
					else
						echo &quot;Unable to connect to ${VPN2}, trying ${VPN3} profile...&quot;
						echo &quot;ifdown ${VPN2}&quot;
						ifdown $VPN2
						sleep $WAITFOR
						echo &quot;ifup ${VPN3}&quot;
						ifup $VPN3
						sleep 7
						network_flush_cache
						network_find_wan NET_IF_NAME
						if [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN3&quot; ]] &amp;&amp; check_fping ; then
							ACTIVEVPN=$VPN3
							CONNECTIONSTATUS=&quot;3&quot;
							echo &quot;${VPN3} is up, and fping success!&quot;
						else 
							echo &quot;Unable to connect to ${VPN3}, trying ${VPN4} profile...&quot;
							echo &quot;ifdown ${VPN3}&quot;
							ifdown $VPN3
							sleep $WAITFOR
							echo &quot;ifup ${VPN4}&quot;
							ifup $VPN4
							sleep 7
							network_flush_cache
							network_find_wan NET_IF_NAME
							if [[ &quot;$NET_IF_NAME&quot; == &quot;$VPN4&quot; ]] &amp;&amp; check_fping ; then
								ACTIVEVPN=$VPN4
								CONNECTIONSTATUS=&quot;3&quot;
								echo &quot;${VPN4} is up and fping success!&quot;
							else
								echo &quot;Unable to start VPN4, or connect to any VPN profiles on $(date)&quot; | tee -a &quot;$log_file&quot;
							fi # Finished VPN4 connect/all VPNx attempts
						fi # Finished VPN3 connect attempt
					fi # Finished VPN2 connect attempt
				fi # Finished VPN1 connect attempt
			else # something is wrong with the basic configuration of the script / interfaces mismatch
				echo &quot;Whoops. Something went wrong!&quot; | tee -a &quot;$log_file&quot;
				echo &quot;Most likely this scripts VPN/WWAN variables are not matched to your router&#039;s interface names.&quot; | tee -a &quot;$log_file&quot;
				echo &quot;Check that your script VPN/WWAN values match the actual interfaces. Exiting...&quot; | tee -a &quot;$log_file&quot;
				break
			fi # Finished check if WWAN or any VPN connection is connected, and establishing required VPN connection if not active already.
		# Else if VPN Selector is set to 0 / no VPN, then
		elif [[ $VPN -eq 0 ]] ; then
			echo &quot;VPN=${VPN}. VPN Selector is turned-off.&quot;
			echo &quot;Checking to see if the current NET_IF_NAME or NET6_IF_NAME matches WWANNAME:&quot;
			network_flush_cache
			network_find_wan NET_IF_NAME
			network_find_wan6 NET6_IF_NAME
			echo &quot;Current values:&quot;
			echo &quot;NET_IF_NAME: ${NET_IF_NAME}&quot;
			echo &quot;NET6_IF_NAME: ${NET6_IF_NAME}&quot;
			echo &quot;WWANNAME interface: ${WWANNAME}&quot;
			echo &quot;WWANDEVICE device: ${WWANDEVICE}&quot;
			if [[ &quot;$WWANNAME&quot; == &quot;$NET_IF_NAME&quot; || &quot;$WWANNAME&quot; == &quot;$NET6_IF_NAME&quot; ]] ; then
				echo &quot;They do. Do nothing here/continue.&quot;
			else
				echo &quot;They do not..&quot;
				echo &quot;Turning off VPN1-4 interfaces (ifdown), in case a VPN was started manually prior to this script run.&quot;
				# VPN may have been manually started prior to current script invocation.
				ifdown $VPN1
				ifdown $VPN2
				ifdown $VPN3
				ifdown $VPN4
				VPNCHANGED=&quot;1&quot;
			fi			
			echo &quot;No VPN active: Setting &#039;CONNECTIONSTATUS&#039; = 2&quot;
			CONNECTIONSTATUS=&quot;2&quot;
			sleep $WAITFOR
		fi # finished for VPN 1/0 Selector check, establishing VPN connection, determining if active VPN has changed from prior VPN interface.

	else # No connectivity: initial or subsequent fping test, whether through VPN or qmippp selection.
		echo &quot;No WAN or VPN connectivity: Fpings failed.&quot;
		if [[ $VPN -eq 1 ]] ; then # If VPN is selected, and basic connectivity is failing,
			echo &quot;VPN Selector is ON, and yet WWAN/VPN is failing at initial fping test.&quot; | tee -a &quot;$log_file&quot;
			echo &quot;This would ordinarily be the case, if you forcibly stopped your WWAN prior to running this script, to test.&quot; | tee -a &quot;$log_file&quot;
			echo &quot;Script will now attempt to (re)connect WWAN ifdown/ifup...&quot; | tee -a &quot;$log_file&quot;
		elif [[ $VPN -eq 0 ]] ; then
			echo &quot;VPN Selector is turned-off in this script and there is no WAN connectivity.&quot; | tee -a &quot;$log_file&quot;
			echo &quot;Script will attempt to (re)connect WWAN ifdown/up...&quot; | tee -a &quot;$log_file&quot;
		fi
		CONNECTIONSTATUS=&quot;1&quot; # reset to unknown
		echo &quot;Attempting to fix connectivity...&quot; | tee -a &quot;$log_file&quot;
		echo &quot;Shutting down all VPN interfaces...&quot; | tee -a &quot;$log_file&quot;
		ifdown $VPN1
		ifdown $VPN2
		ifdown $VPN3
		ifdown $VPN4
		ACTIVEVPN=&quot;none&quot;
		sleep $WAITFOR
		echo &quot;Attempting to restart ${WWANNAME} WWAN interface on $(date).&quot; | tee -a &quot;$log_file&quot;
		echo &quot;Turning off the ${WWANNAME} WWAN interface in ${WAITFOR} seconds..&quot;
		sleep $WAITFOR
		echo &quot;ifdown ${WWANNAME}&quot;
		ifdown $WWANNAME
		echo &quot;Wait 5 seconds then bringing up the ${WWANNAME} interface..&quot;
		sleep 5 # Mandatory 5 seconds
		echo &quot;ifup ${WWANNAME}&quot;
		ifup $WWANNAME
		echo &quot;Wait 60 seconds to give the modem time to reconnect...&quot;
		sleep 60 # give the modem time to reconnect (takes at least 25 seconds for a typical QMI Quectel config. YMMV)
		if check_fping ; then
			CONNECTIONSTATUS=&quot;2&quot;
			echo &quot;SUCCESS: WWAN interface ${WWANNAME} restart worked, no need for reboot.&quot; | tee -a &quot;$log_file&quot;
			sleep $WAITFOR
			NEEDREBOOT=&quot;0&quot;
		else
			echo &quot;FAILURE: reboot required.&quot; | tee -a &quot;$log_file&quot;
			CONNECTIONSTATUS=&quot;0&quot;
			NEEDREBOOT=&quot;1&quot;
		fi # end of follow-up probe to see if WWAN interface restart worked...
	fi # End of initial fping test


	# Now let&#039;s start or restart, as needed, cake-autorate to run:
	# probably should check cake-autorate status and correct if necessary, here
	# Check if cake-autorate is running, and what it is currently using for it&#039;s &#039;ul_if&#039; value:
	echo -e &quot;\n&quot; # new blank line
	echo &quot;CAKECHECK / DOYOULIKECAKE portion of wan-watchdog.sh&quot;
	echo &quot;Detecting interface/SQM/Cake-Autorate and preference status&#039;s..&quot;
	echo &quot;CONNECTIONSTATUS is ${CONNECTIONSTATUS}&quot;
	echo &quot;service cake-autorate status:&quot;
	service cake-autorate status
	echo &quot;service sqm status:&quot;
	service sqm status
	echo &quot;VPNCHANGED/RELOADCAKE is ${VPNCHANGED}&quot;
	echo &quot;DOYOULIKECAKE is ${DOYOULIKECAKE}&quot;
	sleep $WAITFOR
	echo -e &quot;\n&quot; # new blank line

	# if the VPN is selected (1), enabled (on) and running (working) (therefore connectionstatus=3), VPN has not changed from prior, and cake-autorate/sqm are already running:
	# The most typical state when the VPN is selected, and script is running in a loop the second, third etc times.
	if [[ &quot;$CONNECTIONSTATUS&quot; == &quot;3&quot; ]] &amp;&amp; [[ &quot;$(service cake-autorate status)&quot; == &quot;running&quot; ]] &amp;&amp; [[ &quot;$(service sqm status)&quot; == &quot;active with no instances&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; ]] &amp;&amp; [[ &quot;$VPNCHANGED&quot; == &quot;0&quot; ]] ; then 
		echo &quot;Connection Status is 3 -VPN ON &amp; active-, SQM is running, Cake is running, Cake selector is enabled, VPN has NOT changed: Do nothing.&quot;
	# else if all of the above is true but the VPN has changed, and cake-autorate/sqm are already running, restart them:
	elif [[ &quot;$CONNECTIONSTATUS&quot; == &quot;3&quot; ]] &amp;&amp; [[ &quot;$(service cake-autorate status)&quot; == &quot;running&quot; ]] &amp;&amp; [[ &quot;$(service sqm status)&quot; == &quot;active with no instances&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; ]] &amp;&amp; [[ &quot;$VPNCHANGED&quot; == &quot;1&quot; ]] ; then
		echo &quot;Connection Status is 3 -VPN ON &amp; Active-, SQM is running, Cake is running, Cake selector is enabled, VPN has changed: restart SQM/Cake-autorate&quot; | tee -a &quot;$log_file&quot;
		echo &quot;Stopping cake-autorate...&quot;
		echo &quot;service cake-autorate stop&quot;
		service cake-autorate stop
		sleep $WAITFOR
		echo &quot;Stopping SQM...&quot;
		echo &quot;service sqm stop&quot;
		service sqm stop
		sleep $WAITFOR
		echo &quot;service sqm start&quot;
		service sqm start
		sleep $WAITFOR
		# Config.primary.sh in /root/cake-autorate/ will pull the current VPN connection /tmp/currentvpn.txt, and operate on that.
		echo &quot;service cake-autorate start&quot;
		service cake-autorate start
		VPNCHANGED=&quot;0&quot;
		sleep $WAITFOR
	# else if the VPN has not changed, the VPN is active, but cake-autorate is not yet running (typically due to set to &#039;disabled&#039; (from autostart) in System, Startup), then start it:
	elif [[ &quot;$CONNECTIONSTATUS&quot; == &quot;3&quot; ]] &amp;&amp; [[ &quot;$(service cake-autorate status)&quot; == &quot;not running&quot; || &quot;$(service cake-autorate status)&quot; == &quot;inactive&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; ]] ; then
		echo &quot;Cake is NOT running, VPN is ON &amp; active, and cake selector in this script is enabled&quot;
		echo &quot;Stop SQM to verify that SQM is running on the current active VPN interface...&quot;
		echo &quot;service sqm restart&quot;
		service sqm restart
		sleep $WAITFOR
		echo &quot;service cake-autorate start&quot;
		# Config.primary.sh in /root/cake-autorate/ will pull the current VPN connection /tmp/currentvpn.txt, and operate on that.
		service cake-autorate start
		# Initialize VPNCHANGED to 0, because regardless of whether it changed, cake-autorate was not running
		# This can also be the situation during testing sometimes, that VPNCHANGED=1 due to subsequent manual runs of the script.
		VPNCHANGED=&quot;0&quot;
		sleep $WAITFOR
	# atypical: if script was halted/killed manually, a VPN was on, and VPN was changed to &#039;0&#039;, then script was re-executed:
	elif [[ &quot;$CONNECTIONSTATUS&quot; == &quot;2&quot; ]] &amp;&amp; [[ &quot;$(service cake-autorate status)&quot; == &quot;running&quot; ]] &amp;&amp; [[ &quot;$(service sqm status)&quot; == &quot;active with no instances&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; ]] &amp;&amp; [[ &quot;$VPN&quot; == &quot;0&quot; ]] &amp;&amp; [[ &quot;$VPNCHANGED&quot; == &quot;1&quot; ]] ; then 
		echo &quot;VPN active, but VPN selected OFF in script. Restarting SQM/Cake-Autorate to set to ${WWANDEVICE} / ${WWANNAME}:&quot;
		echo &quot;Connection Status is 2, SQM is running, Cake is running, Cake selector is enabled, but this script was probably killed, then re-run while there was a (previous) VPN running:&quot;
		echo &quot;Stopping cake-autorate, restart sqm, restart cake-autorate.&quot;
		echo &quot;service cake-autorate stop&quot;
		service cake-autorate stop
		echo &quot;Restarting SQM to get SQM running on the current active WWAN interface...&quot;
		echo &quot;service sqm restart&quot;
		service sqm restart
		sleep $WAITFOR
		echo &quot;Writing WWANDEVICE to /tmp/currentvpn.txt for Cake-Autorate config.primary.sh to pick-up active interface&quot;
		echo &quot;${WWANDEVICE}&quot; &gt; /tmp/currentvpn.txt # write the current WWAN device (not interface!) to a file, to be used by the cake autorate script.
		sleep $WAITFOR
		echo &quot;service cake-autorate start&quot;
		# Config.primary.sh in /root/cake-autorate/ will pull the current VPN connection /tmp/currentvpn.txt, and operate on that.
		service cake-autorate start
		# Initialize VPNCHANGED to 0
		VPNCHANGED=&quot;0&quot;
		sleep $WAITFOR
	# typical when script running in second, third etc loop and VPN selected OFF
	# else if VPN is selected OFF (0), Connection = 2 (good connection, no vpn), and cake selector is on, and running, do nothing:
	elif [[ &quot;$CONNECTIONSTATUS&quot; == &quot;2&quot; ]] &amp;&amp; [[ &quot;$(service cake-autorate status)&quot; == &quot;running&quot; ]] &amp;&amp; [[ &quot;$(service sqm status)&quot; == &quot;active with no instances&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; ]] &amp;&amp; [[ &quot;$VPN&quot; == &quot;0&quot; ]] ; then 
		echo &quot;VPN selected OFF, CAKE/SQM running.. No change in interfaces: Do Nothing.&quot;
		echo &quot;Connection Status is 2 -VPN selected off, good basic ${WWANNAME} connection-, SQM is running, Cake is running, Cake selector is enabled: Do nothing.&quot;
	# typical on firstboot with VPN off:
	# else if VPN is selected OFF (0), connection = 2 (good connection), and cake selector is ON, but not running:
	elif [[ &quot;$CONNECTIONSTATUS&quot; == &quot;2&quot; ]] &amp;&amp; [[ &quot;$(service cake-autorate status)&quot; == &quot;not running&quot; || &quot;$(service cake-autorate status)&quot; == &quot;inactive&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;1&quot; ]] &amp;&amp; [[ &quot;$VPN&quot; == &quot;0&quot; ]] ; then 
		echo &quot;Connection status is 2, Cake is NOT running, VPN is turned OFF, and cake selector in this script is enabled&quot;
		echo &quot;Restarting SQM to verify that SQM is running on the current active WWAN interface...&quot;
		echo &quot;service sqm restart&quot;
		service sqm restart
		sleep $WAITFOR
		echo &quot;service cake-autorate start&quot;
		echo &quot;$WWANDEVICE&quot; &gt; /tmp/currentvpn.txt # write the current WWAN device (not interface!) to a file, to be used by the cake autorate script.
		sleep $WAITFOR
		# Config.primary.sh in /root/cake-autorate/ will pull the current VPN connection /tmp/currentvpn.txt, and operate on that.
		service cake-autorate start
		sleep $WAITFOR
	# typical when script has been stopped, CAKE selector has been turned off, and script is re-run		
	# else if cake-autorate is running, but cake selector is set to OFF, then shut down cake-autorate:
	elif [[ &quot;$(service cake-autorate status)&quot; == &quot;running&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;0&quot; ]] ; then
		echo &quot;Cake-autorate is running, but DOYOULIKECAKE is turned OFF (0). Turning off/stopping cake-autorate:&quot;
		echo &quot;service cake-autorate stop&quot;
		service cake-autorate stop
		# This can be the case during manually running the script, or if you decided not to use cake-autorate for now, but forgot to disable it from startup
		# or it had been started previously but you don&#039;t want it running rn.
		sleep $WAITFOR
	elif [[ &quot;$(service cake-autorate status)&quot; == &quot;not running&quot; || &quot;$(service cake-autorate status)&quot; == &quot;inactive&quot; ]] &amp;&amp; [[ &quot;$DOYOULIKECAKE&quot; == &quot;0&quot; ]] ; then
		echo &quot;Cake-autorate selector DOYOULIKECAKE turned OFF. Cake not running. Do nothing.&quot;
		sleep $WAITFOR
	fi # Finished starting Cake-autorate for current connection, if selected, restarting, or terminating as necessary.

echo -e &quot;\n&quot; # new blank line
# Pause LOOPWAIT, or in testing-mode exit:
	if [ &quot;$TESTMODE&quot; == &quot;0&quot; ]
	then # now check to see if you should loop or break
		echo &quot;Pausing ${LOOPWAIT} seconds and testing again...&quot;			
		sleep $LOOPWAIT
	elif [ &quot;$TESTMODE&quot; == &quot;1&quot; ]
	then
		echo &quot;Script in testing mode. BOOTWAIT value of ${BOOTWAIT} too low to loop. Exiting..&quot;
		echo &quot;Test run ended: $(date)&quot; | tee -a &quot;$log_file&quot;
		break
	fi

echo -e &quot;\n&quot; # new blank line
done # When CONNECTION STATUS no longer 1 or greater, or break

if [[ &quot;$TESTMODE&quot; == &quot;0&quot; &amp;&amp; $NEEDREBOOT -eq 1 ]]
	then # Test BOOTWAIT value if less/more than 60 to avoid loops.
	echo &quot;Rebooting router in 5 seconds...&quot; | tee -a &quot;$log_file&quot;
	sleep 5
	reboot
elif [[ &quot;TESTMODE&quot; == &quot;1&quot; &amp;&amp; $NEEDREBOOT -eq 1 ]]
	then
	echo &quot;Needs reboot, but script in testing mode... no auto-reboot. Exit.&quot; | tee -a &quot;$log_file&quot;
fi</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Connection probe \/ VPN automation failover script&quot;,&quot;hid&quot;:&quot;connection_probevpn_automation_failover_script&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:10,&quot;range&quot;:&quot;1803-32701&quot;} -->
<h3 class="sectionedit11" id="dynamic_connection">Dynamic connection</h3>
<div class="level3">

<p>
Preserve default route to restore <abbr title="Wide Area Network">WAN</abbr> connectivity when <abbr title="Virtual Private Network">VPN</abbr> is disconnected.
</p>
<pre class="code bash"><span class="co0"># Preserve default route</span>
uci <span class="kw1">set</span> network.wan.metric=<span class="st0">&quot;1024&quot;</span>
uci commit network
service network restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Dynamic connection&quot;,&quot;hid&quot;:&quot;dynamic_connection&quot;,&quot;codeblockOffset&quot;:2,&quot;secid&quot;:11,&quot;range&quot;:&quot;32702-32931&quot;} -->
<h3 class="sectionedit12" id="dynamic_address">Dynamic address</h3>
<div class="level3">

<p>
Periodically re-resolve inactive peer hostnames for <abbr title="Virtual Private Network">VPN</abbr> peers with dynamic <abbr title="Internet Protocol">IP</abbr> addresses.
</p>
<pre class="code bash"><span class="co0"># Periodically re-resolve inactive peers</span>
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;EOF&quot;</span> <span class="sy0">&gt;&gt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>crontabs<span class="sy0">/</span>root
<span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">/</span>usr<span class="sy0">/</span>bin<span class="sy0">/</span>wireguard_watchdog
EOF
uci <span class="kw1">set</span> system.<span class="sy0">@</span>system<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.cronloglevel=<span class="st0">&quot;9&quot;</span>
uci commit system
service cron restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Dynamic address&quot;,&quot;hid&quot;:&quot;dynamic_address&quot;,&quot;codeblockOffset&quot;:3,&quot;secid&quot;:12,&quot;range&quot;:&quot;32932-33268&quot;} -->
<h3 class="sectionedit13" id="race_conditions">Race conditions</h3>
<div class="level3">

<p>
Resolve the <a href="https://forum.openwrt.org/t/problematic-wireguard-at-the-time/56435" class="urlextern" title="https://forum.openwrt.org/t/problematic-wireguard-at-the-time/56435" rel="ugc nofollow">race condition</a> with sysntpd service when RTC is missing.
</p>
<pre class="code bash"><span class="co0"># Resolve race conditions</span>
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;EOF&quot;</span> <span class="sy0">&gt;&gt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>crontabs<span class="sy0">/</span>root
<span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">*</span> <span class="sy0">*</span> <span class="kw2">date</span> <span class="re5">-s</span> <span class="nu0">2030</span>-01-01; service sysntpd restart
EOF
uci <span class="kw1">set</span> system.<span class="sy0">@</span>system<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.cronloglevel=<span class="st0">&quot;9&quot;</span>
uci commit system
service cron restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Race conditions&quot;,&quot;hid&quot;:&quot;race_conditions&quot;,&quot;codeblockOffset&quot;:4,&quot;secid&quot;:13,&quot;range&quot;:&quot;33269-33658&quot;} -->
<h3 class="sectionedit14" id="site-to-site">Site-to-site</h3>
<div class="level3">

<p>
Implement plain routing between server side <abbr title="Local Area Network">LAN</abbr> and client side <abbr title="Local Area Network">LAN</abbr> assuming that:
</p>
<ul>
<li class="level1"><div class="li"> <code>192.168.1.0/24</code> - server side <abbr title="Local Area Network">LAN</abbr></div>
</li>
<li class="level1"><div class="li"> <code>192.168.2.0/24</code> - client side <abbr title="Local Area Network">LAN</abbr></div>
</li>
</ul>

<p>
Add route to client side <abbr title="Local Area Network">LAN</abbr> on <abbr title="Virtual Private Network">VPN</abbr> server.
</p>
<pre class="code bash">uci <span class="kw1">set</span> network.wgclient.route_allowed_ips=<span class="st0">&quot;1&quot;</span>
uci add_list network.wgclient.allowed_ips=<span class="st0">&quot;192.168.2.0/24&quot;</span>
uci commit network
service network restart</pre>

<p>
Add route to server side <abbr title="Local Area Network">LAN</abbr> on <abbr title="Virtual Private Network">VPN</abbr> client.
</p>
<pre class="code bash">uci <span class="kw1">set</span> network.wgserver.route_allowed_ips=<span class="st0">&quot;1&quot;</span>
uci add_list network.wgserver.allowed_ips=<span class="st0">&quot;192.168.1.0/24&quot;</span>
uci commit network
service network restart</pre>

<p>
Consider <abbr title="Virtual Private Network">VPN</abbr> network as private and assign <abbr title="Virtual Private Network">VPN</abbr> interface to <abbr title="Local Area Network">LAN</abbr> zone on <abbr title="Virtual Private Network">VPN</abbr> client.
</p>
<pre class="code bash">uci del_list firewall.wan.network=<span class="st0">&quot;vpn&quot;</span>
uci add_list firewall.lan.network=<span class="st0">&quot;vpn&quot;</span>
uci commit firewall
service firewall restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Site-to-site&quot;,&quot;hid&quot;:&quot;site-to-site&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:14,&quot;range&quot;:&quot;33659-34508&quot;} -->
<h3 class="sectionedit15" id="ipv6_site-to-site">IPv6 site-to-site</h3>
<div class="level3">

<p>
Provide <abbr title="Internet Protocol version 6">IPv6</abbr> site-to-site connectivity assuming that:
</p>
<ul>
<li class="level1"><div class="li"> <code>fd00:0:0:1::/64</code> - server side <abbr title="Local Area Network">LAN</abbr></div>
</li>
<li class="level1"><div class="li"> <code>fd00:0:0:2::/64</code> - client side <abbr title="Local Area Network">LAN</abbr></div>
</li>
</ul>

<p>
Add route to client side <abbr title="Local Area Network">LAN</abbr> on <abbr title="Virtual Private Network">VPN</abbr> server.
</p>
<pre class="code bash">uci <span class="kw1">set</span> network.lan.ip6<span class="re2">assign</span>=<span class="st0">&quot;64&quot;</span>
uci <span class="kw1">set</span> network.lan.ip6<span class="re2">hint</span>=<span class="st0">&quot;1&quot;</span>
uci <span class="kw1">set</span> network.vpn.ip6<span class="re2">prefix</span>=<span class="st0">&quot;fd00::/48&quot;</span>
uci add_list network.wgclient.allowed_ips=<span class="st0">&quot;fd00:0:0:2::/64&quot;</span>
uci commit network
service network restart</pre>

<p>
Add route to server side <abbr title="Local Area Network">LAN</abbr> on <abbr title="Virtual Private Network">VPN</abbr> client.
</p>
<pre class="code bash">uci <span class="kw1">set</span> network.lan.ip6<span class="re2">assign</span>=<span class="st0">&quot;64&quot;</span>
uci <span class="kw1">set</span> network.lan.ip6<span class="re2">hint</span>=<span class="st0">&quot;2&quot;</span>
uci <span class="kw1">set</span> network.vpn.ip6<span class="re2">prefix</span>=<span class="st0">&quot;fd00::/48&quot;</span>
uci add_list network.wgserver.allowed_ips=<span class="st0">&quot;fd00:0:0:1::/64&quot;</span>
uci commit network
service network restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;IPv6 site-to-site&quot;,&quot;hid&quot;:&quot;ipv6_site-to-site&quot;,&quot;codeblockOffset&quot;:8,&quot;secid&quot;:15,&quot;range&quot;:&quot;34509-35231&quot;} -->
<h3 class="sectionedit16" id="default_gateway">Default gateway</h3>
<div class="level3">

<p>
If you do not need to route all traffic to <abbr title="Virtual Private Network">VPN</abbr>.
Disable gateway redirection on <abbr title="Virtual Private Network">VPN</abbr> client.
</p>
<pre class="code bash">uci del_list network.wgserver.allowed_ips=<span class="st0">&quot;0.0.0.0/0&quot;</span>
uci del_list network.wgserver.allowed_ips=<span class="st0">&quot;::/0&quot;</span>
uci commit network
service network restart</pre>

<p>
If you want to disable automatic routes for allowed IPs.
</p>
<pre class="code bash">uci <span class="re5">-q</span> delete network.wgserver.route_allowed_ips
uci commit network
service network restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Default gateway&quot;,&quot;hid&quot;:&quot;default_gateway&quot;,&quot;codeblockOffset&quot;:10,&quot;secid&quot;:16,&quot;range&quot;:&quot;35232-35687&quot;} -->
<h3 class="sectionedit17" id="split_gateway">Split gateway</h3>
<div class="level3">

<p>
If <abbr title="Virtual Private Network">VPN</abbr> gateway is separate from your <abbr title="Local Area Network">LAN</abbr> gateway.
Implement plain routing between <abbr title="Local Area Network">LAN</abbr> and <abbr title="Virtual Private Network">VPN</abbr> networks assuming that:
</p>
<ul>
<li class="level1"><div class="li"> <code>192.168.1.0/24</code> - <abbr title="Local Area Network">LAN</abbr> network</div>
</li>
<li class="level1"><div class="li"> <code>192.168.1.2/24</code> - <abbr title="Virtual Private Network">VPN</abbr> gateway</div>
</li>
<li class="level1"><div class="li"> <code>192.168.9.0/24</code> - <abbr title="Virtual Private Network">VPN</abbr> network</div>
</li>
</ul>

<p>
Add port forwarding for <abbr title="Virtual Private Network">VPN</abbr> server on <abbr title="Local Area Network">LAN</abbr> gateway.
</p>
<pre class="code bash">uci <span class="re5">-q</span> delete firewall.wg
uci <span class="kw1">set</span> firewall.wg=<span class="st0">&quot;redirect&quot;</span>
uci <span class="kw1">set</span> firewall.wg.name=<span class="st0">&quot;Redirect-WireGuard&quot;</span>
uci <span class="kw1">set</span> firewall.wg.src=<span class="st0">&quot;wan&quot;</span>
uci <span class="kw1">set</span> firewall.wg.src_dport=<span class="st0">&quot;51820&quot;</span>
uci <span class="kw1">set</span> firewall.wg.dest=<span class="st0">&quot;lan&quot;</span>
uci <span class="kw1">set</span> firewall.wg.dest_ip=<span class="st0">&quot;192.168.1.2&quot;</span>
uci <span class="kw1">set</span> firewall.wg.family=<span class="st0">&quot;ipv4&quot;</span>
uci <span class="kw1">set</span> firewall.wg.proto=<span class="st0">&quot;udp&quot;</span>
uci <span class="kw1">set</span> firewall.wg.target=<span class="st0">&quot;DNAT&quot;</span>
uci commit firewall
service firewall restart</pre>

<p>
Add route to <abbr title="Virtual Private Network">VPN</abbr> network via <abbr title="Virtual Private Network">VPN</abbr> gateway on <abbr title="Local Area Network">LAN</abbr> gateway.
</p>
<pre class="code bash">uci <span class="re5">-q</span> delete network.vpn
uci <span class="kw1">set</span> network.vpn=<span class="st0">&quot;route&quot;</span>
uci <span class="kw1">set</span> network.vpn.interface=<span class="st0">&quot;lan&quot;</span>
uci <span class="kw1">set</span> network.vpn.target=<span class="st0">&quot;192.168.9.0/24&quot;</span>
uci <span class="kw1">set</span> network.vpn.gateway=<span class="st0">&quot;192.168.1.2&quot;</span>
uci commit network
service network restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Split gateway&quot;,&quot;hid&quot;:&quot;split_gateway&quot;,&quot;codeblockOffset&quot;:12,&quot;secid&quot;:17,&quot;range&quot;:&quot;35688-36701&quot;} -->
<h3 class="sectionedit18" id="ipv6_gateway">IPv6 gateway</h3>
<div class="level3">

<p>
Set up <a href="/docs/guide-user/network/ipv6/ipv6_henet" class="wikilink1" title="docs:guide-user:network:ipv6:ipv6_henet" data-wiki-id="docs:guide-user:network:ipv6:ipv6_henet">IPv6 tunnel broker</a> or use <a href="/docs/guide-user/firewall/fw3_configurations/fw3_nat#ipv6_nat" class="wikilink1" title="docs:guide-user:firewall:fw3_configurations:fw3_nat" data-wiki-id="docs:guide-user:firewall:fw3_configurations:fw3_nat">IPv6 NAT or NPT</a> if necessary.
</p>

<p>
Disable <a href="/docs/guide-user/network/ipv6/ipv6_extras#disabling_gua_prefix" class="wikilink1" title="docs:guide-user:network:ipv6:ipv6_extras" data-wiki-id="docs:guide-user:network:ipv6:ipv6_extras">ISP prefix delegation</a> to prevent <abbr title="Internet Protocol version 6">IPv6</abbr> leaks on <abbr title="Virtual Private Network">VPN</abbr> client.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;IPv6 gateway&quot;,&quot;hid&quot;:&quot;ipv6_gateway&quot;,&quot;codeblockOffset&quot;:14,&quot;secid&quot;:18,&quot;range&quot;:&quot;36702-37031&quot;} -->
<h3 class="sectionedit19" id="dns_over_vpn">DNS over VPN</h3>
<div class="level3">

<p>
<a href="/docs/guide-user/base-system/dhcp_configuration#providing_dns_for_non-local_networks" class="wikilink1" title="docs:guide-user:base-system:dhcp_configuration" data-wiki-id="docs:guide-user:base-system:dhcp_configuration">Serve DNS</a> for <abbr title="Virtual Private Network">VPN</abbr> clients on OpenWrt server when using point-to-point topology.
</p>

<p>
Route <abbr title="Domain Name System">DNS</abbr> over <abbr title="Virtual Private Network">VPN</abbr> to prevent <abbr title="Domain Name System">DNS</abbr> leaks on <abbr title="Virtual Private Network">VPN</abbr> client.
</p>

<p>
<a href="/docs/guide-user/base-system/dhcp_configuration#upstream_dns_provider" class="wikilink1" title="docs:guide-user:base-system:dhcp_configuration" data-wiki-id="docs:guide-user:base-system:dhcp_configuration">Replace peer DNS</a> with public or <abbr title="Virtual Private Network">VPN</abbr>-specific <abbr title="Domain Name System">DNS</abbr> provider on OpenWrt client.
</p>

<p>
Modify the <abbr title="Virtual Private Network">VPN</abbr> connection using NetworkManager on Linux desktop client.
</p>
<pre class="code bash">nmcli connection modify <span class="kw2">id</span> VPN_CON \
ipv4.dns-search ~. ipv4.dns-priority <span class="re5">-50</span> \
ipv6.dns-search ~. ipv6.dns-priority <span class="re5">-50</span></pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;DNS over VPN&quot;,&quot;hid&quot;:&quot;dns_over_vpn&quot;,&quot;codeblockOffset&quot;:14,&quot;secid&quot;:19,&quot;range&quot;:&quot;37032-37645&quot;} -->
<h3 class="sectionedit20" id="kill_switch">Kill switch</h3>
<div class="level3">

<p>
Prevent traffic leaks on OpenWrt client isolating <abbr title="Virtual Private Network">VPN</abbr> interface in a separate firewall zone.
</p>
<pre class="code bash">uci <span class="re5">-q</span> delete firewall.vpn
uci <span class="kw1">set</span> firewall.vpn=<span class="st0">&quot;zone&quot;</span>
uci <span class="kw1">set</span> firewall.vpn.name=<span class="st0">&quot;vpn&quot;</span>
uci <span class="kw1">set</span> firewall.vpn.input=<span class="st0">&quot;REJECT&quot;</span>
uci <span class="kw1">set</span> firewall.vpn.output=<span class="st0">&quot;ACCEPT&quot;</span>
uci <span class="kw1">set</span> firewall.vpn.forward=<span class="st0">&quot;REJECT&quot;</span>
uci <span class="kw1">set</span> firewall.vpn.masq=<span class="st0">&quot;1&quot;</span>
uci <span class="kw1">set</span> firewall.vpn.mtu_fix=<span class="st0">&quot;1&quot;</span>
uci add_list firewall.vpn.network=<span class="st0">&quot;vpn&quot;</span>
uci del_list firewall.wan.network=<span class="st0">&quot;vpn&quot;</span>
uci <span class="re5">-q</span> delete firewall.<span class="sy0">@</span>forwarding<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>
uci <span class="kw1">set</span> firewall.lan_vpn=<span class="st0">&quot;forwarding&quot;</span>
uci <span class="kw1">set</span> firewall.lan_vpn.src=<span class="st0">&quot;lan&quot;</span>
uci <span class="kw1">set</span> firewall.lan_vpn.dest=<span class="st0">&quot;vpn&quot;</span>
uci commit firewall
service firewall restart</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Kill switch&quot;,&quot;hid&quot;:&quot;kill_switch&quot;,&quot;codeblockOffset&quot;:15,&quot;secid&quot;:20,&quot;range&quot;:&quot;37646-38315&quot;} -->
<h3 class="sectionedit21" id="multi-client">Multi-client</h3>
<div class="level3">

<p>
Set up multi-client <abbr title="Virtual Private Network">VPN</abbr> server.
Generate client keys and profiles.
Configure <abbr title="Virtual Private Network">VPN</abbr> peers.
</p>
<pre class="code bash"><span class="co0"># Configuration parameters</span>
<span class="re2">VPN_IDS</span>=<span class="st0">&quot;wgserver wgclient wglaptop wgmobile&quot;</span>
<span class="re2">VPN_PKI</span>=<span class="st0">&quot;.&quot;</span>
<span class="re2">VPN_IF</span>=<span class="st0">&quot;vpn&quot;</span>
<span class="re2">VPN_PORT</span>=<span class="st0">&quot;<span class="es4">$(uci -q get network.${VPN_IF}.listen_port)</span>&quot;</span>
<span class="kw3">read</span> <span class="re5">-r</span> VPN_ADDR VPN_ADDR6 \
<span class="sy0">&lt;</span> <span class="sy0">&lt;</span><span class="br0">&#40;</span>uci <span class="re5">-q</span> get network.<span class="co1">${VPN_IF}</span>.addresses<span class="br0">&#41;</span>
&nbsp;
<span class="co0"># Fetch server address</span>
<span class="re2">NET_FQDN</span>=<span class="st0">&quot;<span class="es4">$(uci -q get ddns.@service[0].lookup_host)</span>&quot;</span>
. <span class="sy0">/</span>lib<span class="sy0">/</span>functions<span class="sy0">/</span>network.sh
network_flush_cache
network_find_wan NET_IF
network_get_ipaddr NET_ADDR <span class="st0">&quot;<span class="es3">${NET_IF}</span>&quot;</span>
<span class="kw1">if</span> <span class="br0">&#91;</span> <span class="re5">-n</span> <span class="st0">&quot;<span class="es3">${NET_FQDN}</span>&quot;</span> <span class="br0">&#93;</span>
<span class="kw1">then</span> <span class="re2">VPN_SERV</span>=<span class="st0">&quot;<span class="es3">${NET_FQDN}</span>&quot;</span>
<span class="kw1">else</span> <span class="re2">VPN_SERV</span>=<span class="st0">&quot;<span class="es3">${NET_ADDR}</span>&quot;</span>
<span class="kw1">fi</span>
&nbsp;
<span class="co0"># Generate client keys</span>
<span class="kw3">umask</span> <span class="re2">go</span>=
<span class="kw2">mkdir</span> <span class="re5">-p</span> <span class="co1">${VPN_PKI}</span>
<span class="kw1">for</span> VPN_ID <span class="kw1">in</span> <span class="co1">${VPN_IDS#* }</span>
<span class="kw1">do</span>
wg genkey \
<span class="sy0">|</span> <span class="kw2">tee</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_ID}</span>.key \
<span class="sy0">|</span> wg pubkey <span class="sy0">&gt;</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_ID}</span>.pub
wg genpsk <span class="sy0">&gt;</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_ID}</span>.psk
<span class="kw1">done</span>
&nbsp;
<span class="co0"># Generate client profiles</span>
<span class="re2">VPN_SFX</span>=<span class="st0">&quot;1&quot;</span>
<span class="kw1">for</span> VPN_ID <span class="kw1">in</span> <span class="co1">${VPN_IDS#* }</span>
<span class="kw1">do</span>
<span class="kw3">let</span> VPN_SFX++
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> EOF <span class="sy0">&gt;</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_ID}</span>.conf
<span class="br0">&#91;</span>Interface<span class="br0">&#93;</span>
PrivateKey = $<span class="br0">&#40;</span><span class="kw2">cat</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_ID}</span>.key<span class="br0">&#41;</span>
Address = <span class="co1">${VPN_ADDR%.*}</span>.<span class="co1">${VPN_SFX}</span><span class="sy0">/</span><span class="nu0">24</span>
Address = <span class="co1">${VPN_ADDR6%:*}</span>:<span class="co1">${VPN_SFX}</span><span class="sy0">/</span><span class="nu0">64</span>
DNS = <span class="co1">${VPN_ADDR%/*}</span>
DNS = <span class="co1">${VPN_ADDR6%/*}</span>
<span class="br0">&#91;</span>Peer<span class="br0">&#93;</span>
PublicKey = $<span class="br0">&#40;</span><span class="kw2">cat</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_IDS%% *}</span>.pub<span class="br0">&#41;</span>
PresharedKey = $<span class="br0">&#40;</span><span class="kw2">cat</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/</span><span class="co1">${VPN_ID}</span>.psk<span class="br0">&#41;</span>
PersistentKeepalive = <span class="nu0">25</span>
Endpoint = <span class="co1">${VPN_SERV}</span>:<span class="co1">${VPN_PORT}</span>
AllowedIPs = 0.0.0.0<span class="sy0">/</span><span class="nu0">0</span>
AllowedIPs = ::<span class="sy0">/</span><span class="nu0">0</span>
EOF
<span class="kw1">done</span>
<span class="kw2">ls</span> <span class="co1">${VPN_PKI}</span><span class="sy0">/*</span>.conf
&nbsp;
<span class="co0"># Back up client profiles</span>
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> EOF <span class="sy0">&gt;&gt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>sysupgrade.conf
$<span class="br0">&#40;</span><span class="kw3">pwd</span> <span class="co1">${VPN_PKI}</span><span class="br0">&#41;</span>
EOF
&nbsp;
<span class="co0"># Add VPN peers</span>
<span class="re2">VPN_SFX</span>=<span class="st0">&quot;1&quot;</span>
<span class="kw1">for</span> VPN_ID <span class="kw1">in</span> <span class="co1">${VPN_IDS#* }</span>
<span class="kw1">do</span>
<span class="kw3">let</span> VPN_SFX++
uci <span class="re5">-q</span> delete network.<span class="co1">${VPN_ID}</span>
uci <span class="kw1">set</span> network.<span class="co1">${VPN_ID}</span>=<span class="st0">&quot;wireguard_<span class="es3">${VPN_IF}</span>&quot;</span>
uci <span class="kw1">set</span> network.<span class="co1">${VPN_ID}</span>.description=<span class="st0">&quot;<span class="es3">${VPN_ID}</span>&quot;</span>
uci <span class="kw1">set</span> network.<span class="co1">${VPN_ID}</span>.private_key=<span class="st0">&quot;<span class="es4">$(cat ${VPN_PKI}/${VPN_ID}.key)</span>&quot;</span>
uci <span class="kw1">set</span> network.<span class="co1">${VPN_ID}</span>.public_key=<span class="st0">&quot;<span class="es4">$(cat ${VPN_PKI}/${VPN_ID}.pub)</span>&quot;</span>
uci <span class="kw1">set</span> network.<span class="co1">${VPN_ID}</span>.preshared_key=<span class="st0">&quot;<span class="es4">$(cat ${VPN_PKI}/${VPN_ID}.psk)</span>&quot;</span>
uci add_list network.<span class="co1">${VPN_ID}</span>.allowed_ips=<span class="st0">&quot;<span class="es3">${VPN_ADDR%.*}</span>.<span class="es3">${VPN_SFX}</span>/32&quot;</span>
uci add_list network.<span class="co1">${VPN_ID}</span>.allowed_ips=<span class="st0">&quot;<span class="es3">${VPN_ADDR6%:*}</span>:<span class="es3">${VPN_SFX}</span>/128&quot;</span>
<span class="kw1">done</span>
uci commit network
service network restart</pre>

<p>
Perform OpenWrt <a href="/docs/guide-user/troubleshooting/backup_restore" class="wikilink1" title="docs:guide-user:troubleshooting:backup_restore" data-wiki-id="docs:guide-user:troubleshooting:backup_restore">backup</a>.
Extract client profiles from the archive and import them to your clients.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Multi-client&quot;,&quot;hid&quot;:&quot;multi-client&quot;,&quot;codeblockOffset&quot;:16,&quot;secid&quot;:21,&quot;range&quot;:&quot;38316-40548&quot;} -->
<h3 class="sectionedit22" id="automated">Automated</h3>
<div class="level3">

<p>
Automated <abbr title="Virtual Private Network">VPN</abbr> server installation and client profiles generation.
</p>
<pre class="code bash"><span class="re2">URL</span>=<span class="st0">&quot;https://openwrt.org/_export/code/docs/guide-user/services/vpn/wireguard/server&quot;</span>
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> EOF <span class="sy0">&gt;</span> wireguard-server.sh
$<span class="br0">&#40;</span><span class="kw2">wget</span> <span class="re5">-U</span> <span class="st0">&quot;&quot;</span> <span class="re5">-O</span> - <span class="st0">&quot;<span class="es3">${URL}</span>?codeblock=0&quot;</span><span class="br0">&#41;</span>
$<span class="br0">&#40;</span><span class="kw2">wget</span> <span class="re5">-U</span> <span class="st0">&quot;&quot;</span> <span class="re5">-O</span> - <span class="st0">&quot;<span class="es3">${URL}</span>?codeblock=1&quot;</span><span class="br0">&#41;</span>
$<span class="br0">&#40;</span><span class="kw2">wget</span> <span class="re5">-U</span> <span class="st0">&quot;&quot;</span> <span class="re5">-O</span> - <span class="st0">&quot;<span class="es3">${URL}</span>?codeblock=2&quot;</span><span class="br0">&#41;</span>
$<span class="br0">&#40;</span><span class="kw2">wget</span> <span class="re5">-U</span> <span class="st0">&quot;&quot;</span> <span class="re5">-O</span> - <span class="st0">&quot;<span class="es3">${URL}</span>?codeblock=3&quot;</span><span class="br0">&#41;</span>
$<span class="br0">&#40;</span><span class="kw2">wget</span> <span class="re5">-U</span> <span class="st0">&quot;&quot;</span> <span class="re5">-O</span> - <span class="st0">&quot;<span class="es3">${URL}</span>/../extras?codeblock=15&quot;</span><span class="br0">&#41;</span>
EOF
<span class="kw2">sh</span> wireguard-server.sh</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Automated&quot;,&quot;hid&quot;:&quot;automated&quot;,&quot;codeblockOffset&quot;:17,&quot;secid&quot;:22,&quot;range&quot;:&quot;40549-&quot;} -->