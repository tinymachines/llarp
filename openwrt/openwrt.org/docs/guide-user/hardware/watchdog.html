
<h1 class="sectionedit1" id="hardware_watchdog">Hardware watchdog</h1>
<div class="level1">

<p>
While older versions of OpenWrt used the watchdog daemon from BusyBox, all new versions implement the watchdog daemon via procd, which is the init process (PID1).
Therefore on modern OpenWrt, you will never see the watchdog process running.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Hardware watchdog&quot;,&quot;hid&quot;:&quot;hardware_watchdog&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-274&quot;} -->
<h2 class="sectionedit2" id="supported_hardware">Supported hardware</h2>
<div class="level2">

<p>
Most embedded devices will have their hardware watchdog enabled in the default kernel configuration of their target, which means it will be built-in (no kmod to install, it&#039;s always available).
</p>

<p>
For x86 hardware you have some kmods to choose:
</p>
<ul>
<li class="level1"><div class="li"> AMD: <a href="/packages/pkgdata/kmod-it87-wdt" class="wikilink1" title="packages:pkgdata:kmod-it87-wdt" data-wiki-id="packages:pkgdata:kmod-it87-wdt">kmod-it87-wdt</a>, <a href="/packages/pkgdata/kmod-sp5100-tco" class="wikilink1" title="packages:pkgdata:kmod-sp5100-tco" data-wiki-id="packages:pkgdata:kmod-sp5100-tco">kmod-sp5100-tco</a></div>
</li>
<li class="level1"><div class="li"> Intel: <a href="/packages/pkgdata/kmod-itco-wdt" class="wikilink1" title="packages:pkgdata:kmod-itco-wdt" data-wiki-id="packages:pkgdata:kmod-itco-wdt">kmod-itco-wdt</a></div>
</li>
<li class="level1"><div class="li"> Generic: <a href="/packages/pkgdata/kmod-w83627hf-wdt" class="wikilink1" title="packages:pkgdata:kmod-w83627hf-wdt" data-wiki-id="packages:pkgdata:kmod-w83627hf-wdt">kmod-w83627hf-wdt</a></div>
</li>
</ul>

<p>
There are also USB-based watchdogs, which will be discussed below in their own sub-section because they are not handled by procd in any way.
</p>

<p>
The procd watchdog code always uses the primary watchdog device <code>/dev/watchdog</code>.
You can configure what watchdog that is (i.e. GSC Watchdog or SoC watchdog) by disabling all but the desired watchdog in the kernel configuration, or not installing watchdog kmods for x86 architecture.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Supported hardware&quot;,&quot;hid&quot;:&quot;supported_hardware&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;275-1157&quot;} -->
<h2 class="sectionedit3" id="controlling_the_watchdog">Controlling the watchdog</h2>
<div class="level2">

<p>
You can see the current configuration of the watchdog service via ubus:
</p>
<pre class="code bash"><span class="co0"># ubus call system watchdog</span>
<span class="br0">&#123;</span>
        <span class="st0">&quot;status&quot;</span>: <span class="st0">&quot;running&quot;</span>,
        <span class="st0">&quot;timeout&quot;</span>: <span class="nu0">30</span>,
        <span class="st0">&quot;frequency&quot;</span>: <span class="nu0">5</span>
<span class="br0">&#125;</span></pre>

<p>
If no watchdog is available, the status parameter is <code>offline</code>. This could also happen when the hardware watchdog driver is built as kmod, as procd tries to initialize the watchdog before loading kernel modules. In this case, it is possible to start the watchdog afterwards:
</p>
<pre class="code bash">ubus call system watchdog <span class="st_h">'{ &quot;stop&quot;: false }'</span></pre>

<p>
While there is no UCI configuration available for these options, you can change them in an rc script such as <code>/etc/rc.local</code>.
</p>
<pre class="code bash"><span class="co0"># Change timeout to 60s</span>
ubus call system watchdog <span class="st_h">'{&quot;timeout&quot;:60}'</span>
&nbsp;
<span class="co0"># Change frequency to 1s</span>
ubus call system watchdog <span class="st_h">'{&quot;frequency&quot;:1}'</span></pre>

<p>
To bypass procd, enable the magicclose feature, stop the service and control the watchdog manually:
</p>
<pre class="code bash">ubus call system watchdog <span class="st_h">'{&quot;magicclose&quot;:true}'</span>
ubus call system watchdog <span class="st_h">'{&quot;stop&quot;:true}'</span>
<span class="kw1">while</span> :; <span class="kw1">do</span> <span class="kw3">echo</span> <span class="nu0">1</span> <span class="sy0">&gt;</span> <span class="sy0">/</span>dev<span class="sy0">/</span>watchdog; <span class="kw2">sleep</span> <span class="nu0">5</span>; <span class="kw1">done</span></pre>

<p>
Note that watchdog will cause a reset after it expires.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Controlling the watchdog&quot;,&quot;hid&quot;:&quot;controlling_the_watchdog&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;1158-2346&quot;} -->
<h2 class="sectionedit4" id="usb_watchdogs">USB watchdogs</h2>
<div class="level2">

<p>
USB-based watchdogs are basically a microcontroller over a USB-serial dongle, that will close/open contacts when they trigger.
These contacts are usually on a header that can be connected to the Power and Reset switch of the board, or to a relay wired to interrupt the power supply to the device.
</p>

<p>
These are some photos of the device I am using:
</p>

<p>
<a href="/_media/docs/guide-user/hardware/usb_watchdog.jpg" class="media" title="docs:guide-user:hardware:usb_watchdog.jpg"><img src="/_media/docs/guide-user/hardware/usb_watchdog.jpg?w=400&amp;tok=2eb3b4" class="media" loading="lazy" alt="" width="400" /></a>
<a href="/_media/docs/guide-user/hardware/usb_watchdog2.jpg" class="media" title="docs:guide-user:hardware:usb_watchdog2.jpg"><img src="/_media/docs/guide-user/hardware/usb_watchdog2.jpg?w=400&amp;tok=ed9dbd" class="media" loading="lazy" alt="" width="400" /></a>
</p>

<p>
This kind of task is trivially easy to also do with an Arduino or Attiny board and some relays.
</p>

<p>
Some USB-based watchdogs are not using a serial dongle, but show up as USB HID devices and I don&#039;t know what is their protocol.
</p>

<p>
This is a script that will generate a procd service to control one of such USB-serial watchdogs.
</p>
<pre class="code bash"><span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;EOF&quot;</span> <span class="sy0">&gt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog
<span class="co0">#!/bin/sh</span>
&nbsp;
<span class="co0"># Watchdog control script for USB-serial based watchdogs</span>
&nbsp;
<span class="co0"># The command to run the watchdog 160 seconds is:</span>
<span class="co0"># echo -n -e &quot;\x10&quot; &gt; /dev/ttyUSB0</span>
<span class="co0"># The &quot;x10&quot; is 16 in hexadecimal and will tell the watchdog to run for 160 seconds, setting a higher (or lower) time is possible,</span>
<span class="co0"># just write a different hexadecimal number, and adjust the number of seconds in the sleep command below.</span>
<span class="co0"># DO NOT use a too small time though or the system will not have enough time to fully reboot before the watchdog triggers again.</span>
&nbsp;
<span class="co0"># First we are detecting what usb serial we need to use, to avoid sending commands to the wrong device, like LTE modems.</span>
<span class="co0"># The device I used appears like this in dmesg when I connect it:</span>
<span class="co0"># [11705.304457] usb 4-1: new full-speed USB device number 2 using uhci_hcd</span>
<span class="co0"># [11705.538687] ch341 4-1:1.0: ch341-uart converter detected</span>
<span class="co0"># [11705.549626] usb 4-1: ch341-uart converter now attached to ttyUSB0</span>
<span class="co0"># So I filter for ch341 serial chips.</span>
&nbsp;
<span class="re2">usb_serial</span>=<span class="st0">&quot;<span class="es4">$(dmesg | sed -n -e &quot;/\sch341.*\stty/s/^.*\s//p&quot;)</span>&quot;</span>
<span class="re2">cmd</span>=<span class="st0">&quot;<span class="es3">${1:-start}</span>&quot;</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#91;</span> <span class="re5">-z</span> <span class="st0">&quot;<span class="es3">${usb_serial}</span>&quot;</span> <span class="br0">&#93;</span>
<span class="kw1">then</span>
    <span class="kw3">echo</span> <span class="st0">&quot;no ch341 serial dongle detected, no watchdog available&quot;</span>
    <span class="kw3">exit</span> <span class="nu0">1</span>
<span class="kw1">fi</span>
&nbsp;
<span class="kw1">case</span> <span class="st0">&quot;<span class="es3">${cmd}</span>&quot;</span> <span class="kw1">in</span>
&nbsp;
<span class="br0">&#40;</span>start<span class="br0">&#41;</span>
<span class="kw3">echo</span> <span class="st0">&quot;starting usb watchdog service&quot;</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">&#91;</span> <span class="sy0">!</span> <span class="re5">-f</span> <span class="sy0">/</span>tmp<span class="sy0">/</span>stop_usb_watchdog <span class="br0">&#93;</span>
<span class="kw1">do</span>
    <span class="kw3">echo</span> <span class="re5">-n</span> <span class="re5">-e</span> <span class="st0">&quot;\x10&quot;</span> <span class="sy0">&gt;</span> <span class="sy0">/</span>dev<span class="sy0">/</span><span class="st0">&quot;<span class="es3">${usb_serial}</span>&quot;</span>
    <span class="kw2">sleep</span> <span class="nu0">30</span>
<span class="kw1">done</span>
<span class="kw2">rm</span> <span class="sy0">/</span>tmp<span class="sy0">/</span>stop_usb_watchdog
&nbsp;
<span class="kw3">echo</span> <span class="st0">&quot;stopping usb watchdog service&quot;</span>
<span class="sy0">;;</span>
&nbsp;
<span class="br0">&#40;</span>stop<span class="br0">&#41;</span>
<span class="kw2">touch</span> <span class="sy0">/</span>tmp<span class="sy0">/</span>stop_usb_watchdog
<span class="sy0">;;</span>
&nbsp;
<span class="br0">&#40;</span><span class="kw2">install</span><span class="br0">&#41;</span>
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;EOI&quot;</span> <span class="sy0">&gt;</span> <span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog
<span class="co0">#!/bin/sh /etc/rc.common</span>
&nbsp;
<span class="re2">USE_PROCD</span>=<span class="nu0">1</span>
<span class="re2">START</span>=<span class="nu0">95</span>
<span class="re2">STOP</span>=01
&nbsp;
start_service<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    procd_open_instance
    procd_set_param <span class="kw3">command</span> <span class="sy0">/</span>bin<span class="sy0">/</span><span class="kw2">sh</span> <span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog
    <span class="co0"># If process dies sooner than respawn_threshold, it is considered crashed and after 5 retries the service is stopped</span>
    procd_set_param respawn <span class="co1">${respawn_threshold:-3600}</span> <span class="co1">${respawn_timeout:-5}</span> <span class="co1">${respawn_retry:-5}</span>
    procd_close_instance
<span class="br0">&#125;</span>
&nbsp;
stop_service<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog stop
<span class="br0">&#125;</span>
EOI
&nbsp;
<span class="kw2">cat</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;EOI&quot;</span> <span class="sy0">&gt;</span> <span class="sy0">/</span>lib<span class="sy0">/</span>upgrade<span class="sy0">/</span>keep.d<span class="sy0">/</span>usb_watchdog
<span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog
<span class="sy0">/</span>etc<span class="sy0">/</span>rc.d<span class="sy0">/</span>
<span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog
EOI
&nbsp;
<span class="kw2">chmod</span> +x <span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog
<span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog <span class="kw3">enable</span>
<span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog start
<span class="sy0">;;</span>
&nbsp;
<span class="br0">&#40;</span>remove<span class="br0">&#41;</span>
<span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog disable
<span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog stop
<span class="kw2">rm</span> <span class="re5">-f</span> <span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog
<span class="kw2">rm</span> <span class="re5">-f</span> <span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog
<span class="kw2">rm</span> <span class="re5">-f</span> <span class="sy0">/</span>lib<span class="sy0">/</span>upgrade<span class="sy0">/</span>keep.d<span class="sy0">/</span>usb_watchdog
<span class="sy0">;;</span>
&nbsp;
<span class="kw1">esac</span>
EOF
<span class="kw2">chmod</span> +x <span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog
<span class="sy0">/</span>etc<span class="sy0">/</span>usb_watchdog <span class="kw2">install</span></pre>

<p>
To install it, write the following commands in your device&#039;s command line interface:
</p>
<pre class="code bash"><span class="kw2">wget</span> <span class="re5">-U</span> <span class="st0">&quot;&quot;</span> <span class="re5">-O</span> usb-watchdog.sh <span class="st0">&quot;https://openwrt.org/_export/code/docs/guide-user/hardware/watchdog?codeblock=3&quot;</span>
. .<span class="sy0">/</span>usb-watchdog.sh</pre>

<p>
You can then control it as normal for a procd service:
</p>
<pre class="code bash"><span class="sy0">/</span>etc<span class="sy0">/</span>init.d<span class="sy0">/</span>usb_watchdog</pre>

<p>
This script also writes the system configuration to survive a system upgrade, so you shouldn&#039;t need to reinstall it when you upgrade.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;USB watchdogs&quot;,&quot;hid&quot;:&quot;usb_watchdogs&quot;,&quot;codeblockOffset&quot;:4,&quot;secid&quot;:4,&quot;range&quot;:&quot;2347-&quot;} -->