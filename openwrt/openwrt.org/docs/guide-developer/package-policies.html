
<h1 class="sectionedit1" id="openwrt_packages">OpenWrt packages</h1>
<div class="level1">

<p>
The OpenWrt system is maintained and distributed as a collection of <em>packages</em>.
</p>

<p>
Almost all pieces of software found in a typical OpenWrt firmware image are
provided by such a package with a notable exception being the Linux kernel itself.
</p>

<p>
The term <em>OpenWrt package</em> may either refer to one of two things:
</p>
<ul>
<li class="level1 node"><div class="li"> an OpenWrt <em>source package</em> which essentially is a directory consisting of:</div>
<ul>
<li class="level2"><div class="li"> an <em>OpenWrt package Makefile</em> describing the acquisition, building and packaging procedures for a piece of software (required)</div>
</li>
<li class="level2"><div class="li"> a supplemental directory with <em>OpenWrt package patches</em> which modify the acquired source code (optional)</div>
</li>
<li class="level2"><div class="li"> other static files that go with the package, such as init script files, default configurations, scripts or other support files (optional)</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> an OpenWrt <em>binary package</em>, which is a GNU tar compatible archive containing binary executable software artifacts and the accompanying <em>package control files</em> for installation on a running system, similar to the <code>.deb</code> or <code>.rpm</code> files used in other package managers</div>
</li>
</ul>

<p>
OpenWrt <em>binary packages</em> are almost exclusively produced from <em>source packages</em>
by invoking either the <em>OpenWrt buildroot</em> or the <em>OpenWrt SDK</em> in order to translate
the source package Makefile descriptions into executable binary artifacts tailored for
a given target system.
</p>

<p>
Although it is possible to manually assemble binary packages by invoking tools such as
<em>tar</em> and placing the appropriate control files in the correct directories, it is
strongly discouraged to do so since such binary packages are usually not easily
reproducible and verifiable.
</p>

<p>
Source packages are developed in multiple OpenWrt <em>package feeds</em> hosted in different
locations and following different purposes. Each <em>package feed</em> is a collection of
<em>source package</em> definitions residing within a publicly or privately reachable source
code repository.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;OpenWrt packages&quot;,&quot;hid&quot;:&quot;openwrt_packages&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-1946&quot;} -->
<h2 class="sectionedit2" id="source_packages">Source packages</h2>
<div class="level2">

<p>
Source packages describe how a piece of software has to be <em>downloaded</em>, <em>patched</em>,
<em>compiled</em> and <em>packaged</em> in order to form a binary software artifact suitable for
use on a running target system. They also describe relations to other source packages
required either at <em>build time</em> or at <em>run time</em>.
</p>

<p>
Each source package should have a <em>globally unique name</em> closely resembling the name
of the software described by it. OpenWrt often follows the lead of other distributions
when deciding about the naming of packages and sticks to the same naming conventions in
many cases.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Source packages&quot;,&quot;hid&quot;:&quot;source_packages&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;1947-2566&quot;} -->
<h3 class="sectionedit3" id="structure">Structure</h3>
<div class="level3">

<p>
A <em>source package</em> is a subdirectory within its corresponding <em>package feed</em>
containing at least one Openwrt <code>Makefile</code> and optionally <code>src</code>, <code>files</code> or
<code>patches</code> directories.
</p>

</div>

<h4 id="makefile">Makefile</h4>
<div class="level4">

<p>
An OpenWrt <em>source package Makefile</em> contains a series of header variable assignments,
action recipes and one or multiple OpenWrt specific signature footer lines identifying it
as OpenWrt specific package Makefile.
</p>

<p>
See <a href="/docs/guide-developer/packages" class="wikilink1" title="docs:guide-developer:packages" data-wiki-id="docs:guide-developer:packages">Creating packages</a> for details
on Makefile contents.
</p>

</div>

<h4 id="the_files_directory">The files directory</h4>
<div class="level4">

<p>
Static files accompanying a source package, such as OpenWrt specific init scripts or
configuration files, must be placed inside a directory called <code>files</code>, residing within
the same subdirectory as the <code>Makefile</code>. There are no strict rules on how such static
files are to be named and organized within the <code>files</code> directory but by convention,
the extension <code>.conf</code> is used for OpenWrt UCI configration files and the extension
<code>.init</code> is used to denote OpenWrt specific init scripts.
</p>

<p>
The actual placement and naming of the resources within the <code>files</code> directory on the
target system is controlled by the source package Makefile and unrelated to the structure
and naming within the <code>files</code> directory.
</p>

</div>

<h4 id="the_patches_directory">The patches directory</h4>
<div class="level4">

<p>
The <code>patches</code> directory must be placed in the same parent directory as the <code>Makefile</code>
file and may only contain <em>patch files</em> used to modify the source code being packaged.
</p>

<p>
Patch files must be in <em>unified diff</em> format and carry the extension <code>.patch</code>.
The file names must also carry a numerical prefix to denote the order in which the patch
files must be applied.
Patch file names should be concise and avoid characters other than <abbr title="American Standard Code for Information Interchange">ASCII</abbr> alphanumerics and hyphens.
</p>

<p>
Suitable patch file names could look like:
</p>
<ul>
<li class="level1"><div class="li"> <code>000-patch-makefile.patch</code></div>
</li>
<li class="level1"><div class="li"> <code>010-backport-frobnicate-crash-fix.patch</code></div>
</li>
<li class="level1"><div class="li"> <code>999-add-local-hack-for-openwrt-compatibility.patch</code></div>
</li>
</ul>

<p>
It is recommended to use <a href="/docs/guide-developer/toolchain/use-patches-with-buildsystem" class="wikilink1" title="docs:guide-developer:toolchain:use-patches-with-buildsystem" data-wiki-id="docs:guide-developer:toolchain:use-patches-with-buildsystem">Quilt</a> to manage source package patch collections.
</p>

</div>

<h4 id="the_src_directory">The src directory</h4>
<div class="level4">

<p>
Some packages do not actually fetch their program code from an external source but bundle
the code to be compiled and packages directly within the package feed. This is usually done
for packages which are specific to OpenWrt and do not exist outside of their respective package feed.
</p>

<p>
Sometimes the <code>src</code> directory may also be used to supply additional code to the compilation
process, in addition to the program code fetched from external sources.
</p>

<p>
If present, the OpenWrt build system will automatically copy the contents of the <code>src</code>
directory verbatim to the compilation scratch directory (<em>build directory</em>) of the package, 
retaining the structure and naming of the files.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Structure&quot;,&quot;hid&quot;:&quot;structure&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;2567-5392&quot;} -->
<h3 class="sectionedit4" id="feature_considerations">Feature Considerations</h3>
<div class="level3">

<p>
Many OpenWrt supported devices still have only a few megabytes of flash and RAM available which makes it important to shrink the packages as much as possible. Opt for the lowest common denominator whenever possible.
</p>

<p>
Some general considerations when packaging a new piece of software are:
</p>
<ul>
<li class="level1"><div class="li"> Do not ship man pages or documentation, a typical installation lacks both the infrastructure and the space to view and store man page databases</div>
</li>
<li class="level1"><div class="li"> Minimize external dependencies - try to avoid optional external dependencies whenever possible. An extreme example is <code>ICU</code> which weighs around 12MB and is an optional dependency for Unicode multi language support in various packages</div>
</li>
<li class="level1"><div class="li"> Modularize packages - if the software you&#039;re packaging supports and uses plugins then put those plugins into separate binary package declarations instead of lumping them all together along with the main program. This way you can externalize dependencies and move them into the plugin packages instead of having them in the main component, which makes the package usable on a wider range of targets because users can omit parts with large dependencies.</div>
</li>
<li class="level1"><div class="li"> Try to rely on standard facilities - instead of requiring extra programs to implement tasks like user context switching, use the <code>procd</code> facilities to run a service as a different user.</div>
</li>
</ul>

<p>
Often it is tempting to add various <code>menuconfig</code> configuration options to allow the customization of the package features by the users compiling their own variant of OpenWrt but it should be kept in mind that large parts of the userbase will use the package solely by installing binary archives from the OpenWrt repositories.
</p>

<p>
Binary packages in the official OpenWrt repositories are always built with the default settings of a package so a maintainer should ensure that the default feature selection represents a fair balance between resource requirements and most common user needs.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Feature Considerations&quot;,&quot;hid&quot;:&quot;feature_considerations&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:4,&quot;range&quot;:&quot;5393-7341&quot;} -->
<h3 class="sectionedit5" id="copyright_statements">Copyright statements</h3>
<div class="level3">

<p>
Historically, packages for OpenWrt used to contain a copyright notice at the top of the Makefile, stating something like:
</p>
<pre class="code"># Copyright (C) 2007-2010 OpenWrt.org
This is free software, licensed under the GNU General Public License v2.
See /LICENSE for more information.</pre>

<p>
Since contributors likely do not have a formal contract with OpenWrt to develop packages, they cannot disclaim their own copyrights and assign them to the project.
</p>

<p>
When adding new packages, please don&#039;t simply copy the statement from another package but add either your own in the form:
</p>
<pre class="code"># Copyright (C) 2016 Joe Random &lt;joe@example.org&gt;</pre>

<p>
or omit it entirely.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Copyright statements&quot;,&quot;hid&quot;:&quot;copyright_statements&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;7342-8013&quot;} -->
<h3 class="sectionedit6" id="versioning">Versioning</h3>
<div class="level3">

<p>
There are a number of Makefile variables influencing the visible version of the resulting packages. When packaging upstream release tarballs, the <code>PKG_VERSION</code> variable should be set to the version of the upstream software being packaged.
For example, if the <code>openssl</code> package compiles the released <code>openssl-1.0.2q.tar.gz</code> archive, then <code>PKG_VERSION</code> variable should be set to the value <code>1.0.2q</code>.
</p>

<p>
When there are no upstream release tarballs available or when software is packaged straight from a source code repository, the <code>PKG_SOURCE_DATE</code> and <code>PKG_SOURCE_VERSION</code> variables should be used instead. The <code>PKG_SOURCE_DATE</code> value must correspond to the modification date in the format <code>YYYY-MM-DD</code> of the source repository revision being packaged and <code>PKG_SOURCE_VERSION</code> must be set to the corresponding revision identifier of the repository, e.g. the commit hash for Git or the revision number for SVN repositories.
For example, if the <code>ubus</code> package clones from Git revision <a href="https://git.openwrt.org/?p=project/ubus.git;a=commitdiff;h=221ce7e7ff1bd1a0c9995fa9d32f58e865f7207f" class="urlextern" title="https://git.openwrt.org/?p=project/ubus.git;a=commitdiff;h=221ce7e7ff1bd1a0c9995fa9d32f58e865f7207f" rel="ugc nofollow">https://git.openwrt.org/?p=project/ubus.git;a=commitdiff;h=221ce7e7ff1bd1a0c9995fa9d32f58e865f7207f</a>, then its Makefile should specify <code>PKG_SOURCE_DATE:=2018-10-06</code> and <code>PKG_SOURCE_VERSION:=221ce7e7ff1bd1a0c9995fa9d32f58e865f7207f</code>.
</p>

<p>
The build system will combine these variables into a common version identifier and truncate the revision identifier if needed. Given the values in the example, the resulting version identifier will be <code>2018-10-06-221ce7e7</code>. This is done to make repository revision identifiers comparable to each other since SCM systems like Git or Mercurial use SHA hashes to identify revisions which are no monotonically increasing numerical values.
</p>

</div>

<h4 id="package_revisions">Package Revisions</h4>
<div class="level4">

<p>
Source packages must specify a <code>PKG_RELEASE</code> value identifying the revision of the source package. In contrast to the <code>PKG_VERSION</code>, <code>PKG_SOURCE_DATE</code> and <code>PKG_SOURCE_VERSION</code> variables which are identifying the upstream version of the program code being packaged, the <code>PKG_RELEASE</code> variable denotes the revision of the package itself.
</p>

<p>
The package revision should start with the value <code>1</code> and must be increased whenever modifications are made to the package which might cause changes to the executables or other files contained within the resulting binary packages. When the package is updated to a newer <code>PKG_VERSION</code> or <code>PKG_SOURCE_VERSION</code>, the <code>PKG_RELEASE</code> must be reset back to <code>1</code>.
</p>

<p>
Some examples for dealing with the <code>PKG_RELEASE</code> are:
</p>
<ul>
<li class="level1"><div class="li"> Fixed a typo in the maintainer&#039;s mail address → <code>PKG_RELEASE</code> stays unchanged</div>
</li>
<li class="level1"><div class="li"> Added a <code>--disable-acl</code> to the configure arguments → <code>PKG_RELEASE</code> is incremented</div>
</li>
<li class="level1"><div class="li"> Updated <code>libfoo</code> from version <code>0.2.1</code> to <code>0.2.2</code> → <code>PKG_RELEASE</code> is reset to <code>1</code> and <code>PKG_VERSION</code> set to <code>0.2.2</code></div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Versioning&quot;,&quot;hid&quot;:&quot;versioning&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:6,&quot;range&quot;:&quot;8014-10814&quot;} -->
<h3 class="sectionedit7" id="downloading">Downloading</h3>
<div class="level3">

<p>
When declaring the source download method in the Makefile, direct tarball downloads via <abbr title="Hypertext Transfer Protocol">HTTP</abbr>
or <abbr title="Hypertext Transfer Protocol Secure">HTTPS</abbr> are the preferred way to acquire package sources, Git or other SCM clones should be avoided, mainly to keep the locally cached source downloads reproducible.
</p>

<p>
If direct Git cloning is required (for example because there is no release tarballs available upstream) then Git via <abbr title="Hypertext Transfer Protocol Secure">HTTPS</abbr> is preferred over Git via <abbr title="Hypertext Transfer Protocol">HTTP</abbr> is preferred over Git via its native protocol. Many OpenWrt users are behind corporate firewalls which disallow Git native traffic (<abbr title="Transmission Control Protocol">TCP</abbr> 9418).
</p>

</div>

<h4 id="mirror_sites">Mirror Sites</h4>
<div class="level4">

<p>
The use of mirror sites for tarball download locations is encouraged and helps to reduce the traffic load on upstream project sites. When choosing mirrors for a package, please try to ensure that the mirror is:
</p>
<ul>
<li class="level1"><div class="li"> officially endorsed by the upstream project (E.G. mentioned on their download page).</div>
</li>
<li class="level1"><div class="li"> well reachable by people from a wide range of different locations.</div>
</li>
<li class="level1"><div class="li"> using proper <abbr title="Secure Socket Layer">SSL</abbr> certificates when using <abbr title="Hypertext Transfer Protocol Secure">HTTPS</abbr>.</div>
</li>
<li class="level1"><div class="li"> hosting the most current version of the software in question.</div>
</li>
</ul>

<p>
Multiple mirrors can be specified in a package Makefile by assigning a white-space separated list of URLs to the <code>PKG_SOURCE_<abbr title="Uniform Resource Locator">URL</abbr></code> variable.
It is a good convention to assign the upstream project site itself to the end of the mirror list.
This provides a canonical fallback location in case a new version has not yet propagated to all mirrors and conveys the original download location to casual readers.
</p>

<p>
Try to limit the amount of mirror sites to 3 to 5 different locations, including the main download site.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Downloading&quot;,&quot;hid&quot;:&quot;downloading&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:7,&quot;range&quot;:&quot;10815-12422&quot;} -->
<h3 class="sectionedit8" id="building">Building</h3>
<div class="level3">

<p>
The build recipes in a source package should adhere to the OpenWrt defaults as much as possible. This ensures that source package declarations remain compact and free of copy-pasted boilerplate
code.
</p>

<p>
By default, the build system uses a set of standard <code>./configure</code> and <code>make</code> invocations to build packages in a refined manner. Most of these steps can be influenced through a number of variables to alter the way the actual commands are executed.
</p>

<p>
Please refer to <a href="https://git.openwrt.org/?p=openwrt/openwrt.git;a=blob;f=include/package-defaults.mk" class="urlextern" title="https://git.openwrt.org/?p=openwrt/openwrt.git;a=blob;f=include/package-defaults.mk" rel="ugc nofollow">package-defaults.mk</a> to learn how the default recipes are implemented.
</p>

<p>
Whenever possible, try to avoid redefining the default macros but use the provided variables to encode functional differences.
</p>

<p>
Example for a bad redefinition:
</p>
<pre class="code">define Build/Compile 
        (cd $(PKG_BUILD_DIR)/nonstandard/dir/; make)
endef</pre>

<p>
Example for achieving the same using variable overrides:
</p>
<pre class="code">MAKE_PATH := nonstandard/dir/</pre>

<p>
Likewise, do not attempt to override <code>Build/Configure</code> but use <code>CONFIGURE_ARGS</code> to pass switches like <code>CONFIGURE_ARGS += --enable-acl</code> or <code>CONFIGURE_ARGS += --without-systemd</code> and <code>CONFIGURE_VARS</code> to pass environment variables to the configuration script, like <code>CONFIGURE_VARS += ac_cv_func_snprintf=yes</code>.
</p>

</div>

<h4 id="hooks">Hooks</h4>
<div class="level4">

<p>
In some cases it is possible to arrange things before e.g. the
<code>./configure</code> script is invoked in order to touch files, remove things
or echo values into stampfiles. In such cases, it is permissible to
redefine the recipe in order to achieve the desired result. Use the
default implementations of the macros to call the original behaviour
after the custom work is done. Refer to the examples below for some
common use cases.
</p>

</div>

<h5 id="running_custom_commands_after_unpacking_but_before_patching_the_sources">Running custom commands after unpacking but before patching the sources:</h5>
<div class="level5">
<pre class="code">define Build/Prepare
	echo &quot;1.2.3&quot; &gt; $(PKG_BUILD_DIR)/version.txt
	$(call Build/Prepare/Default)
endef</pre>

</div>

<h5 id="running_custom_commands_after_unpacking_and_patching_the_sources">Running custom commands after unpacking and patching the sources:</h5>
<div class="level5">
<pre class="code">define Build/Prepare
	$(call Build/Prepare/Default)
	rm -f $(PKG_BUILD_DIR)/m4/libtool.m4
	cp $(PKG_BUILD_DIR)/make/Makefile.linux $(PKG_BUILD_DIR)/Makefile
endef</pre>

</div>

<h5 id="running_custom_commands_before_invoking_configure">Running custom commands before invoking configure:</h5>
<div class="level5">
<pre class="code">define Build/Configure
	touch $(PKG_BUILD_DIR)/ChangeLog
	$(call Build/Configure/Default)
endef</pre>

</div>

<h5 id="running_custom_commands_after_executing_make">Running custom commands after executing make:</h5>
<div class="level5">
<pre class="code">define Build/Compile
	$(call Build/Compile/Default)
	cp $(PKG_BUILD_DIR)/src/libfoo.so.1.2 $(PKG_BUILD_DIR)/src/libfoo.so
endef</pre>

</div>

<h4 id="autotools">Autotools</h4>
<div class="level4">

<p>
Many open source projects rely on GNU autoconf and automake as their build system which may lead to a number of problems in a cross compilation setting.
</p>

<p>
Usual problems revolve around:
</p>
<ul>
<li class="level1"><div class="li"> <code>configure</code> scripts attempting to call programs to test certain features which might fail if the called program has been built for another architecture</div>
</li>
<li class="level1"><div class="li"> Pregenerated <code>configure</code> scripts embedding faulty and possibly outdated versions of <code>libtool</code> causing runtime problems on the target system</div>
</li>
<li class="level1"><div class="li"> Macros in configure scripts probing host system details to configure the package for the target, like calling <code>uname</code> to figure out the kernel version or endianess</div>
</li>
<li class="level1"><div class="li"> Projects shipping convenience scripts like <code>autogen.</code>sh which make certain assumptions about the host system or try to call the improper version of utilities like <code>autopoint</code> or <code>autoconf,</code> leading to macro errors and version mismatches when executing the generated configure scripts and Makefiles</div>
</li>
</ul>

<p>
Due to the complex nature of the GNU autoconf/automake system there is no single set of solutions to a given problem but rather a general list of guidelines and best practices to adhere to.
</p>
<ul>
<li class="level1"><div class="li"> Never patch the generated / shipped <code>configure</code> script but fix the underlying <code>configure.ac</code> or <code>configure.in</code> files and rely on the <code>PKG_FIXUP:=autoreconf</code> facility to regenerate the config script. This also has the nice side-effect of updating the embedded <code>libtool</code> version and using a cross-compile-safe set of standard macros, replacing unsafe ones in many cases.</div>
</li>
<li class="level1"><div class="li"> Make <code>./configure</code> invocations as explicit as possible by forcibly disabling or enabling any feature which depends on the presence of an external library, e.g. <code>--disable-acl</code> to build a given package without <code>libacl</code> support on both systems having <code>libacl</code> in their staging directory and systems not providing this library. Failure to do so will result in errors like <code>Package example is missing dependencies for the following libraries: libfoo.so.1</code> on systems that happen to build <code>libfoo</code> before building example.</div>
</li>
<li class="level1"><div class="li"> Pre-seed <code>configure</code> tests that cannot be reliably determined in a cross-compile setting. Properly written autoconf test macros can be overridden by cache-variables in the form <code>ac_cv_somename=value</code> - use this facility to skip tests which would otherwise fail or result in host-system specific values. For example the <code>libpcap</code> package passes <code>ac_cv_linux_vers=$(LINUX_VERSION)</code> to prevent <code>./configure</code> from calling the host systems <code>uname</code> in order to figure out the kernel version. The names of the involved cache variables can be found in the <code>config.log</code> file within the package build directory or by inspecting the generated shell code of the <code>configure</code> program. Use the <code>CONFIGURE_VARS</code> variable to pass the cache variables down to the actual <code>./configure</code> invocation</div>
</li>
<li class="level1"><div class="li"> Never trust shipped <code>autogen.sh</code> and similar scripts, rather use <code>PKG_FIXUP:=autoreconf</code> to (re)generate the configure script and automake templates and encode additionally needed steps in the appropriate build recipes.</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Building&quot;,&quot;hid&quot;:&quot;building&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:8,&quot;range&quot;:&quot;12423-18092&quot;} -->
<h2 class="sectionedit9" id="dependencies">Dependencies</h2>
<div class="level2">

<p>
A <em>source package</em> may depend on a number of other packages, either to satisfy compilation
requirements or to enforce the presence of specific functionality, such as shared libraries
or support programs at runtime on the target system.
</p>

<p>
There are two kinds of dependencies; <em>build dependencies</em>, specified by the 
<code>PKG_BUILD_DEPENDS</code> Makefile variable and <em>runtime dependencies</em>, declared in the
<code>DEPENDS</code> variable of the corresponding <code>define Package/...</code> Makefile sections.
</p>

<p>
<em>Build dependencies</em> are resolved at package compilation time and instruct the build system
to download, patch and compile each mentioned dependency before the source package itself
is compiled. This is required when the compilation process of a package depends on resources
such as header files from another package. <em>Build dependencies</em> are not transformed into
<em>runtime dependencies</em> and should only be used when the resources of the packages being
depended upon are solely required at compilation time. This usually is the case for header-only
libraries such as the C++ Boost project or static <code>.a</code> library archives that result in no
dynamic runtime requirements.
</p>

<p>
<em>Runtime dependencies</em>, on the other hand, specify the relation of <em>binary packages</em>,
instructing the package manager to fetch and install the listed dependencies before installing
the binary package itself. A <em>runtime dependency</em> automatically implies a <em>build 
dependency</em>, so if a <code>DEPENDS</code> variable within a <code>define Package/...</code> section of a given 
source package specifies the name of a <code>define Package/...</code> section of another source 
package, the build system will take care of compiling the other package before compiling 
the source package specifiying the runtime dependency.
</p>

<p>
Package dependencies, regardless of whether they&#039;re build-time or runtime ones, should only 
require packages within the same <em>package feed</em> or provided by the <em>base feed</em> located 
within the main OpenWrt <code>package/</code> directory.
</p>

<p>
Dependencies among packages in different, non-base feeds are strongly discouraged as it is
not guaranteed that each build system has access to all feeds.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Dependencies&quot;,&quot;hid&quot;:&quot;dependencies&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:9,&quot;range&quot;:&quot;18093-20273&quot;} -->
<h2 class="sectionedit10" id="shared_libraries">Shared libraries</h2>
<div class="level2">

<p>
Packages providing shared libraries require additional care to ensure that software depending
on these libraries remains functional and is not accidentally broken by incompatible updates,
changed APIs, removed functionality and so on.
</p>

<p>
While the package dependency mechanisms will ensure that the build system compiles library
packages before the program packages requiring them, they do not guarantee that such programs
are getting rebuilt when the library package itself is updated.
</p>

<p>
Also, in the case of binary package repositories, installing a newer, incompatible version of 
library packages would break installed programs relying on this library unless an additional
version constraint is applied to the dependency.
</p>

<p>
The OpenWrt build system introduced the concept of an <code>ABI_VERSION</code> to address the issue
of program dependencies on specific versions of a shared library, requiring exactly the ABI
the program was initially compiled and linked against. The <code>ABI_VERSION</code> value is supposed
to reflect the <code>SONAME</code> of the library being packaged.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Shared libraries&quot;,&quot;hid&quot;:&quot;shared_libraries&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:10,&quot;range&quot;:&quot;20274-21361&quot;} -->
<h3 class="sectionedit11" id="soname">SONAME</h3>
<div class="level3">

<p>
Most upstream libraries contain an <a href="https://en.wikipedia.org/wiki/Soname" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Soname">ELF SONAME</a>
attribute denoting the canonical name of the library including a version suffix specifying
the version of the exposed ABI. Changes breaking the exposed ABI usually result in a change
to the <code>SONAME</code>.
</p>

<p>
When a program is linked against such a library, the linker will resolve the <code>SONAME</code> of
the requested shared object and put it into the <code>DT_NEEDED</code> section of the resulting program
executable. Upon starting the program, the dynamic linker on the target system will consult the
<code>DT_NEEDED</code> section to find the required libraries within the standard library search path.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;SONAME&quot;,&quot;hid&quot;:&quot;soname&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:11,&quot;range&quot;:&quot;21362-22019&quot;} -->
<h3 class="sectionedit12" id="abi_version">ABI Version</h3>
<div class="level3">

<p>
Setting an <code>ABI_VERSION</code> variable on a library package definition will cause the build system
to track the value of this variable and trigger recompilations in all packages depending on
this library package whenever the value is incremented. This is useful to force re-linking of 
all programs after a library has been changed to an incompatible version.
</p>

<p>
The <code>ABI_VERSION</code> value is also appended to the binary package name and all dependencies
mentioning the binary library package will be automatically expanded to contain the
<code>ABI_VERSION</code> suffix. If for example a library package <code>libfoo</code> specifies
<code>ABI_VERSION:=1.0</code>, the resulting binary package will be called <code>libfoo1.0</code> and when a
package <code>bar</code> specifies <code>DEPENDS:=+libfoo</code>, the resulting runtime dependency will be
<code>Depends: libfoo1.0</code>.
</p>

<p>
This ensures that incompatible updates to the <code>libfoo</code> library, denoted by an <code>ABI_VERSION</code>
increase, will cause programs linked against it from then on to have a different runtime dependency, allowing the OpenWrt package manager to notice the change.
</p>

<p>
Example: when <code>libfoo</code> is updated to a new, incompatible version and its <code>SONAME</code> property
changed from <code>libfoo.so.1.0</code> to <code>libfoo.so.1.1</code>, then <code>ABI_VERSION</code> should be increased
from <code>1.0</code> to <code>1.1</code>, causing the resulting <code>libfoo</code> binary package to be called
<code>libfoo1.1</code>. Source packages linking <code>libfoo</code> from then on, will have runtime dependencies
on <code>libfoo1.1</code>.
</p>

<p>
When a shared library is packaged, the <code>ABI_VERSION</code> variable of the corresponding
<code>define Package/lib...</code> section should be set to the <code>SONAME</code> of the <code>.so</code> library file
contained within the binary package. The <code>SONAME</code> usually reflects the library&#039;s internal
<code>ABI</code> version and is incremented whenever incompatible changes to the public APIs are made
within the library, E.G. when changing a function call signature or when removing exported
symbols.
</p>

<p>
The public <a href="https://abi-laboratory.pro/index.php?view=tracker" class="urlextern" title="https://abi-laboratory.pro/index.php?view=tracker" rel="ugc nofollow">ABI tracker</a> is useful to 
decide whether an <code>ABI_VERSION</code> change is required when updating an existing library package
to a newer upstream version.
</p>

<p>
Some upstream library projects do not use a <code>SONAME</code> at all or do not properly version
their libraries, in such cases, the <code>ABI_VERSION</code> must be set to a value in the form <code>YYYYMMDD</code>,
reflecting the source code change date of the last incompatible change being made.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;ABI Version&quot;,&quot;hid&quot;:&quot;abi_version&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:12,&quot;range&quot;:&quot;22020-24459&quot;} -->
<h3 class="sectionedit13" id="contents">Contents</h3>
<div class="level3">

<p>
In order to allow multiple versions of binary library packages to coexist on the same system,
each library package should only contain shared object files specific to the <code>SONAME</code> version
of the library getting packaged.
</p>

<p>
A typical upstream library <code>libbar</code> with version 1.2.3 and <code>SONAME</code> of <code>libbar.so.1</code>
will usually provide these files after compilation:
</p>
<pre class="code">libbar.so       -&gt; libbar.so.1.2.3 (symlink)
libbar.so.1     -&gt; libbar.so.1.2.3 (symlink)
libbar.so.1.2.3      (shared library object)</pre>

<p>
The binary <code>libbar1</code> package should only contain <code>libbar.so.1</code> and <code>libbar.so.1.2.3</code> as
the common <code>libbar.so</code> symlink would clash with a <code>libbar2</code> package providing version
<code>2.0.0</code> of <code>libbar</code>.
</p>

<p>
Versionless symlinks are usually not needed for libraries using the <code>SONAME</code> attribute
and are only used during the linking phase when compiling programs depending on the library.
</p>

</div>

<h4 id="note">NOTE</h4>
<div class="level4">

<p>
<code>$(INSTALL_DATA)</code> and <code>$(INSTALL_BIN)</code> will currently copy the file contents instead of the
symlink itself, so prefer <code>$(CP)</code> when copying the library symlinks.  Consider the example
above, if you run
</p>
<pre class="code">$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/libbar.so.* $(1)/usr/lib/</pre>

<p>
it will result in two copies of the library in regular files:
</p>
<pre class="code">libbar.so.1               (regular file)
libbar.so.1.2.3           (regular file)</pre>

<p>
Instead, use
</p>
<pre class="code">$(CP) $(PKG_INSTALL_DIR)/usr/lib/libbar.so.* $(1)/usr/lib/</pre>

<p>
and you&#039;ll get the intended result:
</p>
<pre class="code">libbar.so.1     -&gt; libbar.so.1.2.3 (symlink)
libbar.so.1.2.3                    (regular file)</pre>

<p>
While there has been a proposal to change <code>$(INSTALL_BIN)</code> behavior, <code>$(CP)</code> will continue
to work.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Contents&quot;,&quot;hid&quot;:&quot;contents&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:13,&quot;range&quot;:&quot;24460-26146&quot;} -->
<h3 class="sectionedit14" id="development_files">Development Files</h3>
<div class="level3">

<p>
Source packages defining binary packages that ship shared libraries should declare a <code>Build/InstallDev</code>
recipe that copies all resources required to discover and link the shared libraries into the staging directory.
</p>

<p>
A typical <code>InstallDev</code> recipe usually copies all library symlinks (including the unversioned ones),
header files and, in case they&#039;re provided, pkg-config (<code>*.pc</code>) files.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Development Files&quot;,&quot;hid&quot;:&quot;development_files&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:14,&quot;range&quot;:&quot;26147-&quot;} -->